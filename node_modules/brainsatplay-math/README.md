# brainsatplay-math
 Brains@Play math stuff. Math2 contains all static methods. These get assigned to the main Math object as well as an extension

 * genSineWave() //generate a sine wave
 * getSineAmplitude() //get amplitude of a sine at time t
 * mean() //array mean
 * mode() //array mode
 * std() //standard dev
 * relError() //relative error
 * informationEntropy() //trying to build a maxent distribution off of this stuff
 * zscore() //array z score
 * variance() //variance
 * dot() //dot product (n-dimensional)
 * cross3D() //3d cross product (n-dimensional)
 * magnitude() //vector magnitude (n-dimensional)
 * distance() //distance function p1-p2 (n-dimensional)
 * normalize() //vector normalization (n-dimensional)
 * normalizeSeries() //clamp array values between 0 or -1 and 1 using max and min
 * newtonsMethod() //root approximation
 * integral() //1d integral
 * dintegral() //2d integral
 * tintegral() //3d integral
 * pintegral() //2d path integral
 * makeVec([1,2,3],[3,4,5]) //subtract two points to make a vector
 * getBufferedValueByCoordinates() //provide a buffered 1D matrix/vertex buffer, any dimensions, and the coordinates and optionally the cardinal you want to extract. Can get the whole vector by coordinate or single value.
 * mapBufferedMat(buffer=[0,1,2,3...],dimensions=[x,y,...],asIndex:(v,idx,x,y..)=>{}|[(v,idx,x,y..)=>{},(v,idx,x,y...)=>{}]) //iterate an array buffer with the matrix coordinates of each buffer, use the asIndex function to run operations on that coordinate, or an array of functions e.g. to specify rgb color or xyz axis specific operators, returns a new array buffer.
 * combinations(choices,vecsize); //create array of vectors of set size containing every combination from a given array of choices
 * generateCoordinateSpace(upperBounds=[10,10,10],lowerBounds=[-10,-10,-10],stepSizes=[1,1,1]) //generate a coordinate space between the upper and lower bounds, with each dimension having its own step size specifiable as a number or function, e.g. one function could be a time increment on its own interval and the rest are cartesian coordinates
 * meshgrid(upperBounds=[10,10,10],lowerBounds=[-10,-10,-10],stepSizes=[1,1,1]) //same as generateCoordinateSpace but named after the common python/matlab function
 * calcVectorField(generateCoordinateSpace(),formula=(...vec)=>{return vec.map(d => d*0.5)}) //pass a genenerated coordinate space and a formula that returns results for each vector in the coordinate space, e.g. navier stokes
 * transpose(mat) //2d mat transpose
 * matmul(a,b) //2d mat mul
 * matscale(mat,scalar) //2d mat scalar
 * matadd(a,b) //2d mat add
 * matsub(a,b)  //2d mat subtract
 * normalDistribution(samples=[], normalize=true) //create a normal (gaussian) distribution
 * expectedValue(samples=[],probabilities=this.normalDistribution(samples)) //get expected value of an array
 * originMoment(samples=[],probabilities=this.normalDistribution(samples),order=1) //statistical moment about origin
 * centralMoment(samples=[],probabilities=this.normalDistribution(samples),order=1) //statistical moment about mean
 * linearDiscriminantAnalysis(samples=[], classifier=[]) //LDA
 * conv1D(arr=[],kern=[],pad=0) //1d convolution //1d convolution
 * conv2D(mat=[[],[],[]],kern=[[],[],[]],pad=0) //2d convolution
 * cov2d(mat) //2d covariance
 * cov1d(arr1=[],arr2=[]) //1d covariance
 * cov3d(x=[],y=[],z=[]) //3d covariance
 * covNd(dimensionalData=[]) //nd covariance
 * eigens2x2(mat=[[1,2],[3,4]]) //fast 2x2 eigenvalue 
 * eigenvectors2x2(mat=[[1,2],[3,4]], eigens=[1,2]) //fast 2x2 eigenvector 
 * fastpca2d(xarr,yarr) //fast 2d pca
 * crosscorrelation(arr1,arr2) //crosscor
 * autocorrelation(arr1) //autocor
 * autocorrelation2d(mat2d=[[],[],...]) //2d autocorrelation
 * autocorrelation2dNormalized(mat2d=[[],[],...]) //normalized 2d autocorrelation
 * dft(arr=[]) //discrete fourier transform (slow)
 * correlograms(dat=[[],[]]) //return cross correlations of many signals
 * sma(arr=[], window) //simple moving average 
 * sum(arr=[]) //array sum
 * reduceArrByFactor(arr,factor=2) //reduce array sizes
 * makeArr(startValue, stopValue, nSteps) //linspace
 * autoscale(array,stackedLines=1,stackPosition=0,centerZero=false)//autoscale array between -1 and 1, can be used for stacking lines e.g. in webgl
 * absmax(array) //returns the absolute value maximum of an array 
 * downsample(data, fitCount, scalar=1)  //downsample array, different formula than interpolateArray
 * interpolateArray(data, fitCount, scalar=1) //or upsample(data, fitCount, scalar=1), upsampling array with spring factor  
 * isExtrema(arr,critical='peak') //peak or valley
 * isCriticalPoint(arr,critical='peak') //peak, valley
 * peakDetect = (smoothedArray,type='peak',window=49) //wider window to find less peaks
 * getPeakThreshold(arr, peakIndices, thresholdVar)
 * eigens(M=[[],[]], tolerance=0.0001, max_iterations=1000)
 * pca(mat=[[],[]],tolerance = 0.00001) //power iteration method PCA
 * eigenvalue_of_vector(mat, eigenvector)
 * power_iteration(mat, tolerance=0.00001, max_iterations=1000)
 * squared_difference(v1, v2)
 * flatten_vector(v) //column to row
 * column(mat, x) //row to column