//By Joshua Brewster (AGPL), who is bad at math...


/**
 * Math2 Contains All Static Methods, these get assigned without conflict to the Math object as well when you import this script
 * We'll add more useful static things like filter kernels etc. as we get to making them.
 * 
 * //Just type these and the variable inputs that pop up should be easy to follow. Everything is commented otherwise till we document it
 * genSineWave() //generate a sine wave
 * getSineAmplitude() //get amplitude of a sine at time t
 * mean() //array mean
 * mode() //array mode
 * std() //standard dev
 * relError() //relative error
 * informationEntropy() //trying to build a maxent distribution off of this stuff
 * zscore() //array z score
 * variance() //variance
 * dot() //dot product
 * cross3D() //3d cross product
 * magnitude() //vector magnitude
 * distance() //distance function p1-p2
 * normalize() //vector normalization
 * normalizeSeries() //clamp array values between 0 or -1 and 1 using max and min
 * newtonsMethod() //root approximation
 * integral() //1d integral
 * dintegral() //2d integral
 * tintegral() //3d integral
 * pintegral() //2d path integral
 * makeVec([1,2,3],[3,4,5]) //subtract two points to make a vector
 * getBufferedValueByCoordinates() //provide a buffered 1D matrix/vertex buffer, any dimensions, and the coordinates and optionally the cardinal you want to extract. Can get the whole vector by coordinate or single value.
 * mapBufferedMat(buffer=[0,1,2,3...],dimensions=[x,y,...],asIndex:(v,i,x,y..)=>{}|[(v,i,x,y..)=>{},(v,i,x,y...)=>{}]) //iterate an array buffer with the matrix coordinates of each buffer, use the asIndex function to run operations on that coordinate, or an array of functions e.g. to specify rgb color or xyz axis specific operators, returns a new array buffer.
 * combinations(choices,vecsize); //create array of vectors of set size containing every combination from a given array of choices
 * generateCoordinateSpace(upperBounds=[10,10,10],lowerBounds=[-10,-10,-10],stepSizes=[1,1,1]) //generate a coordinate space between the upper and lower bounds, with each dimension having its own step size specifiable as a number or function, e.g. one function could be a time increment on its own interval and the rest are cartesian coordinates
 * meshgrid(upperBounds=[10,10,10],lowerBounds=[-10,-10,-10],stepSizes=[1,1,1]) //same as generateCoordinateSpace but named after the common python/matlab function
 * calcVectorField(generateCoordinateSpace(),formula=(...vec)=>{return vec.map(d => d*0.5)}) //pass a genenerated coordinate space and a formula that returns results for each vector in the coordinate space, e.g. navier stokes
 * transpose(mat) //2d mat transpose
 * matmul(a,b) //2d mat mul
 * matscale(mat,scalar) //2d mat scalar
 * matadd(a,b) //2d mat add
 * matsub(a,b)  //2d mat subtract
 * normalDistribution(samples=[], normalize=true) //create a normal (gaussian) distribution
 * expectedValue(samples=[],probabilities=this.normalDistribution(samples)) //get expected value of an array
 * originMoment(samples=[],probabilities=this.normalDistribution(samples),order=1) //statistical moment about origin
 * centralMoment(samples=[],probabilities=this.normalDistribution(samples),order=1) //statistical moment about mean
 * linearDiscriminantAnalysis(samples=[], classifier=[]) //LDA
 * conv1D(arr=[],kern=[],pad=0) //1d convolution //1d convolution
 * conv2D(mat=[[],[],[]],kern=[[],[],[]],pad=0) //2d convolution
 * cov2d(mat) //2d covariance
 * cov1d(arr1=[],arr2=[]) //1d covariance
 * cov3d(x=[],y=[],z=[]) //3d covariance
 * covNd(dimensionalData=[]) //nd covariance
 * eigens2x2(mat=[[1,2],[3,4]]) //fast 2x2 eigenvalue 
 * eigenvectors2x2(mat=[[1,2],[3,4]], eigens=[1,2]) //fast 2x2 eigenvector 
 * fastpca2d(xarr,yarr) //fast 2d pca
 * crosscorrelation(arr1,arr2) //crosscor
 * autocorrelation(arr1) //autocor
 * autocorrelation2d(mat2d=[[],[],...]) //2d autocorrelation
 * autocorrelation2dNormalized(mat2d=[[],[],...]) //normalized 2d autocorrelation
 * dft(arr=[]) //discrete fourier transform (slow)
 * correlograms(dat=[[],[]]) //return cross correlations of many signals
 * sma(arr=[], window) //simple moving average 
 * sum(arr=[]) //array sum
 * reduceArrByFactor(arr,factor=2) //reduce array sizes
 * makeArr(startValue, stopValue, nSteps) //linspace
 * HSLtoRGB(h,s,l,scalar=255) //convert hsl to rgb, returns array
 * autoscale(array,stackedLines=1,stackPosition=0,centerZero=false)//autoscale array between -1 and 1, can be used for stacking lines e.g. in webgl
 * absmax(array) //returns the absolute value maximum of an array 
 * downsample(data, fitCount, scalar=1)  //downsample array, different formula than interpolateArray
 * interpolateArray(data, fitCount, scalar=1) //or upsample(data, fitCount, scalar=1), upsampling array with spring factor  
 * lerp(v0,v1,fit,floor?) //linearly interpolate (linspace) between two values with a specified fit count, can make sure all values are rounded down too.
 * isExtrema(arr,critical='peak') //peak or valley
 * isCriticalPoint(arr,critical='peak') //peak, valley
 * peakDetect = (smoothedArray,type='peak',window=49) //wider window to find less peaks
 * getPeakThreshold(arr, peakIndices, thresholdVar)
 * eigens(M=[[],[]], tolerance=0.0001, max_iterations=1000)
 * pca(mat=[[],[]],tolerance = 0.00001) //power iteration method PCA
 * eigenvalue_of_vector(mat, eigenvector)
 * power_iteration(mat, tolerance=0.00001, max_iterations=1000)
 * squared_difference(v1, v2)
 * flatten_vector(v) //column to row
 * column(mat, x) //row to column
 * circularBuffer(arr:any[],newData:any|any[]) //push new entries to end of array and roll over starting entries with a set array length
 * 
 */



export class Math2 {
	constructor() {}

	//----------------------------------------------------------------
	//-------------------- Static Variables---------------------------
	//----------------------------------------------------------------

	//Throwing a bunch in here for the hell of it
	static TWO_PI = Math.PI * 2; 			//2PI
	static C = 299792458; 				//speed of light m/s
	static G = 6.67430e-11; 			//Newton's gravitation constant N*m^2 / kg^2
	static h = 6.62607015e-34; 			//Planck constant J*s
	static R = 8.31432e3; 				//Universal gas constant J / kg*mol*K
	static Ra = 287; 					//Air gas constant J / kg*K
	static H = 69.3; 					//Hubble constant km/s/Mpc 
	static kbar = 1.054571817e-34; 		//Dirac constant J*s
	static kB = 1.380649e-23; 			//Boltzmann constant J/K
	static ke = 8.9875517923e9; 		//Coulomb constant kg * m^3 * s^-2 * C^-2
	static me = 9.1093837015e-31; 		//electron mass kg
	static mp = 1.67262192369e-27; 		//proton mass kg
	static mn = 1.67492749804e-27; 		//neutron mass kg
	static P0 = 1.01325e5; 				//Sea level pressure N/m^2
	static T0 = 288.15; 				//Sea level room temperature K
	static p0 = 1.225; 					//Sea level air density kg/m^3
	static Na = 6.0220978e23; 			//Avogadro's number 1 / kg*mol
	static y = 1.405; 					//Adiabatic constant
	static M0 = 28.96643; 				//Sea level molecular weight
	static g0 = 9.80665; 				//Sea level gravity m/s^2
	static Re = 6.3781e6; 				//Earth radius m
	static B = 1.458e-6; 				//Thermal constant Kg / m*s*sqrt(kg)
	static S = 110.4; 					//Sutherland's constant K
	static Sigma = 3.65e-10; 			//Collision diameter of air m

	static imgkernels = {
		edgeDetection: [
			[-1, -1, -1],
			[-1, 8, -1],
			[-1, -1, -1]
		], boxBlur: [
			[1 / 9, 1 / 9, 1 / 9],
			[1 / 9, 1 / 9, 1 / 9],
			[1 / 9, 1 / 9, 1 / 9]
		], sobelLeft: [
			[1, 0, -1],
			[2, 0, -2],
			[1, 0, -1]
		], sobelRight: [
			[-1, 0, 1],
			[-2, 0, 2],
			[-1, 0, 1]
		], sobelTop: [
			[1, 2, 1],
			[0, 0, 0],
			[-1, -2, -1]
		], sobelBottom: [
			[-1, 2, 1],
			[0, 0, 0],
			[1, 2, 1]
		], identity: [
			[0, 0, 0],
			[0, 1, 0],
			[0, 0, 0]
		], gaussian3x3: [
			[1, 2, 1],
			[2, 4, 2],
			[1, 2, 1]
		], guassian7x7: [
			[0, 0, 0, 5, 0, 0, 0],
			[0, 5, 18, 32, 18, 5, 0],
			[0, 18, 64, 100, 64, 18, 0],
			[5, 32, 100, 100, 100, 32, 5],
			[0, 18, 64, 100, 64, 18, 0],
			[0, 5, 18, 32, 18, 5, 0],
			[0, 0, 0, 5, 0, 0, 0],
		], emboss: [
			[-2, -1, 0],
			[-1, 1, 1],
			[0, 1, 2]
		], sharpen: [
			[0, -1, 0],
			[-1, 5, -1],
			[0, -1, 0]
		]
	};

	//----------------------------------------------------------------
	//-------------------- Static Functions --------------------------
	//----------------------------------------------------------------

	//Generate sinewave, you can add a noise frequency in too. Array length will be Math.ceil(fs*nSec)
	static genSineWave(freq = 20, peakAmp = 1, nSec = 1, fs = 512, freq2 = 0, peakAmp2 = 1) {
		var sineWave = [];
		var t = [];
		var increment = 1 / fs; //x-axis time increment based on sample rate
		for (var ti = 0; ti < nSec; ti += increment) {
			var amplitude = Math.sin(2 * Math.PI * freq * ti) * peakAmp;
			amplitude += Math.sin(2 * Math.PI * freq2 * ti) * peakAmp2; //Add interference
			sineWave.push(amplitude);
			t.push(ti);
		}
		return [t, sineWave]; // [[times],[amplitudes]]
	}

	//get the sine amplitude at a particular time (seconds)
	static getSineAmplitude(frequency = 20, peakAmplitude = 1, ti = 0, tOffset = 0) {
		return Math.sin(this.TWO_PI * frequency * ti + tOffset) * peakAmplitude;
	}

	//average value of array
	static mean(arr) {
		var sum = arr.reduce((prev, curr) => curr += prev);
		return sum / arr.length;
	}

	//array mode (most commonly occurring number)
	static mode(arr) {
		return arr.sort((a, b) =>
			arr.filter(v => v === a).length
			- arr.filter(v => v === b).length
		).pop();
	}

	//standard deviation
	static std(arr, mean = undefined) {
		let avg = mean;
		if (!mean) avg = this.mean(arr);
		let summed = 0;
		for (let i = 0; i < arr.length; i++) {
			let subbed = arr[i] - avg;
			summed += subbed * subbed;
		}

		return Math.sqrt(summed / arr.length);
	}

	//find the relative error of predicted results
	static relError(actual = [], forecast = [], abs = true) {
		if (actual.length !== forecast.length) throw new Error('Input arrays of same length!');
		let i = actual.length;
		let d = new Array(actual.length) //relative errors
		for (let j = 0; j < i; j++) {
			let dd = (actual[j] - forecast[j]) / actual[j];
			if (abs) dd = Math.abs(dd);
			d[j] = dd;
		}
		return d;
	}

	//returns information entropy in natural units (base e)
	static informationEntropy(probabilities = []) {
		let len = probabilities.length;
		let entropy = new Array(len);
		for (let i = 0; i < len; i++) {
			let ent = probabilities[i] * Math.log(probabilities[i]);
			if (isNaN(ent)) ent = 0;
			entropy[i] = ent;
		}

		return entropy;
	}

	//array zscore (probabilities)
	static zscore(arr) {
		let mean = this.mean(arr);
		let std = this.std(arr, mean);
		let z = new Array().length(arr.length);
		for (let i = 0; i < arr.length; i++) {
			z[i] = (arr[i] - mean) / std;
		}

		return z;
	}

	static variance(arr) { //Variance of 1D input arrays of length n
		var mean = this.mean(arr);
		return arr.reduce((a, b) => a + ((b - mean) ** 2), 0) / arr.length;
	}

	static dot(vec1, vec2) { //nDimensional vector dot product
		var dot = 0;
		for (var i = 0; i < vec1.length; i++) {
			dot += vec1[i] * vec2[i];
		}
		return dot;
	}

	static cross3D(vec1, vec2) { //3D vector cross product
		return [
			vec1[1] * vec2[2] - vec1[2] * vec2[1], //x
			vec1[2] * vec2[0] - vec1[0] * vec2[2], //y
			vec1[0] * vec2[1] - vec1[1] * vec2[0]  //z
		];
	}

	static magnitude(vec) { //nDimensional magnitude
		var sqrd = 0;
		vec.forEach((c) => {
			sqrd += c * c;
		})
		return Math.sqrt(sqrd)
	}

	static distance(point1, point2) { //nDimensional vector distance function
		var dsqrd = 0;
		point1.forEach((c, i) => {
			dsqrd += (point2[i] - c) * (point2[i] - c);
		})
		return Math.sqrt(dsqrd);
	}

	//n dimensional vector midpoint formula
	static midpoint(point1 = [1, 2, 3], point2 = [3, 4, 5]) {
		return point1.map((c, i) => { return (c + point2[i]) * 0.5; });
	}

	static normalize(vec) { //nDimensional vector normalization using the magnitude of the vector
		var norm = 0;
		norm = this.magnitude(vec);
		var vecn = new Array(vec.length);
		vec.forEach((c, i) => {
			vecn[i] = c * norm;
		})
		return vecn;
	}

	static normalizeSeries(arr = [], fromZero = true) { //clamps an array to 0 - 1 if fromZero=true or -1 to 1
		let max = Math.max(...arr);
		let min = Math.min(...arr);
		if (fromZero == false) {
			max = Math.max(max, Math.abs(min));
			min = 0;
		}
		if (max - min === 0) {
			min = 0;
			if (max === 0) max = 0.0000000000001;
		}
		return arr.map(v => (v - min) / (max - min));
	}

	//return the quadratic roots based on your input ax^2 + bx + c = 0
	static quadraticFormula(a, b, c) {
		let bbmac4 = Math.sqrt(b * b - 4 * a * c);
		if (!isNaN(bbmac4)) return ['complex', 'complex'];
		let _a2 = 1 / (2 * a);
		if (bbmac4 === 0) return [b * _a2];
		let nb = -b;
		return [(nb + bbmac4) * _a2, ((nb - bbmac4) * _a2)];
	}

	//approximation of function roots. Provide a function (1d), window, and precision and it will return approximate roots along that window
	static newtonsMethod(foo = (x) => { return Math.pow(x, 5) + x * x - x - 0.2 }, start = 0, end = 1, precision = 0.01, attempts = 10) {
		let roots = [];

		for (let i = 0; i < attempts; i++) {
			let seedx = Math.random() * (end - start);
			let guess = foo(seedx);
			let guess2 = foo(seedx + precision);
			let slope = (guess2 - guess) / precision;

			let xn = seedx + precision;
			while ((Math.abs(slope) > precision)) {
				let step = -guess / slope;
				let xn1 = xn + step;
				guess = guess2;
				guess2 = foo(xn1);
				let slope = (guess2 - guess) / (xn1 - xn);
			}

			let idx;
			let f = roots.find((root, i) => {
				if (Math.abs(xn1 - root) < precision) {
					idx = i;
					return true;
				}
			});
			if (f) roots[idx] = (xn1 + f) * 0.5;
			else roots.push(xn1);
		}
		return roots;
	}

	//2D integral approximation using rectangular area under the curve. If you need absolute values be sure to return that.
	static integral = (func = (x) => { let y = x; return y; }, range = [], stepx = 0.01) => {
		let area = 0;
		for (let i = range[0]; i < range[1]; i += stepx) {
			let y = func(i);
			area += y * stepx;
		}
		return area;
	}

	//3D double integral approximation
	static dintegral = (func = (x, y) => { let z = x + y; return z; }, range = [[], []], stepx = 0.01, stepy = stepx) => {
		let volume = 0;
		for (let i = range[0][0] + stepx; i < range[0][1]; i += stepx) {
			for (let j = range[1][0] + stepy; j < range[1][1]; j += stepy) {
				let z = func(i, j);
				volume += z * stepx * stepy;
			}
		}
		return volume;
	}

	//4D triple integral approximation
	static tintegral = (func = (x, y, z) => { let w = x + y + z; return w; }, range = [[], [], []], stepx = 0.01, stepy = stepx, stepz = stepx) => {
		let volume = 0;
		for (let i = range[0][0] + stepx; i < range[0][1]; i += stepx) {
			for (let j = range[1][0] + stepy; j < range[1][1]; j += stepy) {
				for (let k = range[2][0] + stepz; k < range[2][1]; k += stepz) {
					let w = func(i, j, k);
					volume += w * stepx * stepy * stepz;
				}
			}
		}
		return volume;
	}

	//2D path integral approximation (the length of a curve)
	static pintegral = (func = (x) => { let y = x; return y; }, range = [], stepx = 0.01) => {
		let length = 0;
		let y0 = undefined;
		let yi = undefined;
		for (let i = range[0]; i < range[1]; i += stepx) {
			y0 = yi;
			yi = func(i);
			if (y0)
				length += this.distance([0, y0], [stepx, yi]);
		}
		return length;
	}

	static makeVec(point1, point2) {  //Make vector from two nDimensional points (arrays)
		var vec = [];
		point1.forEach((c, i) => {
			vec.push(point2[i] - c);
		})
		return vec;
	}

	static getBufferedValueByCoordinates(
		vb=new Array(300).fill(1), //10x10x1 vec3s = 150 points, 0 and 1 = 150x2 = 300 points
		dims=[10,10,2],  //10x10x2 (2 z layers for 0 and 1)
		coordinate=[1,2,1], //0-9,0-9,0-1
		cardinal=undefined //null,0,1..
	) {

		let getIdx = (foundIdx = 0, dimIdx=0) => {
			if(dimIdx === dims.length) return foundIdx;
			if(dimIdx == 0)  foundIdx += coordinate[dimIdx];
			else if (dims[dimIdx] == 0) dimsAt0++;
			else {
				let reMul = (val=coordinate[dimIdx], di=dimIdx-1) => {
					val *= dims[di];
					di--;
					if(di == 0) return val;
					else return reMul(val,di); 
				}
				foundIdx += reMul(coordinate[dimIdx]+1,dimIdx-1);
			}
			dimIdx++;
			return getIdx(foundIdx,dimIdx);
		}

		let found = getIdx();

		if(cardinal) {
			if(coordinate[coordinate.length-1] === 0) {
				let lastnonzero = 0;
				let idx = 0;
				while(idx !== coordinate.length - 1) {
					if(coordinate[idx] !== 0) lastnonzero = idx;
					idx++;
				}
				return vb[found - lastnonzero + cardinal];
			}
			return vb[found - dims.length + cardinal];
		}
		else {
			if(coordinate[coordinate.length-1] === 0) {
				let lastnonzero = 0;
				let idx = 0;
				while(idx !== coordinate.length - 1) {
					if(coordinate[idx] !== 0) lastnonzero = idx;
					idx++;
				}
				return vb.slice(found - lastnonzero, found+1);	
			}
			return vb.slice(found - dims.length, found+1);
		}
	}

	//simpler for for loop recursion for buffered matrices e.g. an srgb array we want to map by coordinates
	static forBufferedMat(
		vb=new Array(100).fill(1),
		dims=[10,10], 
		asIndex=(v,i,x,y) => {return v+x+y;}
		//OR: asIndex=[(v,i,x,y) => {return v+x+y;},(v,i,x,y) => {return 2*v+x+y;}]
	) {

		let coordinate = [];
		let idx = 0;
		let recurseFor = (depth=0,nextDepth=depth+1) => {
			let result = new Array(vb.length);
			for(let di = 0; di<dims[depth]; di++) {
				coordinate[depth] = di;
				if(dims[nextDepth]) recurseFor(nextDepth);
				else { 
					result[idx] = asIndex(vb[idx],idx,...coordinate);
					idx++;
				}
			}
			return result;
		}

		let recurseForArrFuncs = (depth, nextDepth=depth+1) => {
			let result = new Array(vb.length);
			for(let di = 0; di<dims[depth]; di++) {
				coordinate[depth] = di;
				if(dims[nextDepth]) recurseFor(nextDepth);
				else { 
					for(let dj = 0; dj < dims.length; dj++) {
						result[idx] = asIndex[dj](vb[idx],idx,...coordinate)
						idx++;
					}
				}
			}
			return result;
		}

		if(typeof asIndex === 'function') {
			return recurseFor();
		} else if (Array.isArray(asIndex)) {
			return recurseForArrFuncs();
		}

	}

	//we work with 1D arraybuffers of n-dimensional matrices in most cases so this can recursively iterate the array
	static mapBufferedMat(
		buffer = new Array(100).fill(1),
		dimensions = [10, 10],
		asIndex = (v, idx, i, j) => { console.log(`value:${v}, idx:${idx}, x:${i},y:${j}`); return v + i + j; } //first half of the args will be the buffer values, second half will be the coordinates
		//OR: asIndex = [(v,idx,i,j)=>{console.log('do something with x!', x); return v*2;},(v,idx,i,j)=>{console.log('do something with y!', y); return y/5;}]
	) {
		let coordinate = new Array(dimensions.length).fill(0);

		const iterateCoordinate = (coord, idx = 0) => {
			if (coord[idx] >= dimensions[idx]) {
				coord[idx] = 0;
				idx++;
				if (idx === dimensions.length) return;
				iterateCoordinate(coord, idx);
			}
			else coord[idx]++;
		}

		let result = new Array(buffer.length);
		let i = 0;
		if (typeof asIndex === 'function') { //supply a function to apply to every value in a buffer
			while (i < buffer.length) {
				result[i] = asIndex(buffer[i], i, ...coordinate);
				i += dimensions.length;
				iterateCoordinate(coordinate);
			}
		}
		else if (Array.isArray(asIndex)) {
			while (i < buffer.length) {
				asIndex.forEach((func) => { //or supply an array of functions to apply per-value e.g. for RGB coordinates 
					result[i] = func(buffer[i], i, ...coordinate);
					i++;
					iterateCoordinate(coordinate);
				});
			}
		}

		return result;

	}

	//https://stackoverflow.com/questions/28655651/javascript-recursion-creating-n-level-for-loops
	static combinations(
		choices = ['a', 'b', 'c'],
		vecsize = 3 //returns an N x M vector, number of choices * vector size
	) { //create 2d array with sub arrays of size n for every possible combination from an array of possible elements 
		var result = [];
		if (vecsize <= 0) {
			result.push([]);
		} else {
			Math2.combinations(choices, vecsize - 1).forEach(function (previousComb) {
				choices.forEach(function (element) {
					result.push([element].concat(previousComb));
				});
			});
		}
		return result;
	} //n-level loops of the same size

	//create an n-dimensional vector/tensor field; (meshgrid from python/matlab)
	static generateCoordinateSpace(
		upperBounds = [10, 10, 10], //arguments will be integer coordinates for each combination of coordinates from zero to the prescribed dimensions
		lowerBounds = [-10, -10, -10], //less than upper bounds //dimensions with fixed values should have the same upper and lower bound 
		steps = [1, 1, 1], //number or step function, a function should return a decrement value based on the current coordinate (kinda useless but it is useful for making mixed density point clouds)
		mutater = undefined//(generated)=>{return generated;} //you can return a mutated coordinate e.g. applying initial conditions or adding extra vector values derived from functions driving your vector field
	) {

		for (let i = 0; i < upperBounds.length; i++) { //some correction
			if (lowerBounds[i] > upperBounds[i]) {
				let temp = upperBounds[i];
				upperBounds[i] = lowerBounds[i];
				lowerBounds[i] = temp;
			}
		}

		let result = [];

		let copy = [...upperBounds];
		let lastindex = copy.length - 1;

		result.push([...copy]);

		while (copy[0] >= lowerBounds[0]) {

			let checkNextIndex = (decrIdx) => {
				if (copy[decrIdx] <= lowerBounds[decrIdx]) {
					if (decrIdx === 0) return; //last step
					copy[decrIdx] = upperBounds[decrIdx];
					decrIdx--;
					if (decrIdx < 0) return; //-1 idx does not exist
					if (typeof steps[decrIdx] == 'function') copy[decrIdx] -= steps[decrIdx](copy[decrIdx])
					else copy[decrIdx] -= steps[decrIdx];
					checkNextIndex(decrIdx);
				}
			}

			let decrIdx = lastindex;
			if (typeof steps[decrIdx] == 'function') copy[decrIdx] -= steps[decrIdx](copy[decrIdx])
			else copy[decrIdx] -= steps[decrIdx];
			result.push([...copy]);
			checkNextIndex(decrIdx);

			if (mutater) result[result.length - 1] = mutater(result[result.length - 1]);
		}

		return result;
	}

	static meshgrid = Math2.generateCoordinateSpace;

	static calcVectorField( //pass an n-dimensional coordinate space and apply a formula to each coordinate, return mapped results
		coordinates = [[0, 0], [0, 1], [1, 0], [1, 1]], //2d array from generateNDArrays provides the coordinate space (or seed tensors whatever)
		formula = (x, y) => { //function passes each coordinate provided
			return [x * 10, y * 10];
		}
	) {
		return coordinates.map(vec => formula(...vec));
	}

	static transpose(mat) {
		return mat[0].map((_, colIndex) => mat.map(row => row[colIndex]));
	}

	//2D Matrix multiplication from: https://stackoverflow.com/questions/27205018/multiply-2-matrices-in-javascript
	static matmul(a, b) {
		var aNumRows = a.length, aNumCols = a[0].length,
			bNumRows = b.length, bNumCols = b[0].length,
			m = new Array(aNumRows);  // initialize array of rows
		for (var r = 0; r < aNumRows; ++r) {
			m[r] = new Array(bNumCols); // initialize the current row
			for (var c = 0; c < bNumCols; ++c) {
				m[r][c] = 0;             // initialize the current cell
				for (var i = 0; i < aNumCols; ++i) {
					m[r][c] += a[r][i] * b[i][c];
				}
			}
		}
		return m;
	}

	//Apply scalar to 2D matrix 
	static matscale(mat, scalar) {
		let m = [];
		for (var i = 0; i < mat.length; i++) {
			m[i] = [];
			for (let j = 0; j < mat[0].length; j++) {
				m[i][j] = mat[i][j] * scalar;
			}
		}
		return m;
	}

	//2d matrix addition
	static matadd(a, b) {
		let m = [];
		for (let i = 0; i < a.length; i++) {
			m[i] = [];
			for (var j = 0; j < a[0].length; j++) {
				m[i][j] = a[i][j] + b[i][j];
			}
		}
		return m;
	}

	//2d matrix subtraction
	static matsub(a, b) {
		let m = [];
		for (let i = 0; i < a.length; i++) {
			m[i] = [];
			for (var j = 0; j < a[0].length; j++) {
				m[i][j] = a[i][j] - b[i][j];
			}
		}
		return m;
	}

	//return a histogram of the array, use nBins to override binSize
	static histogram(arr = [], binSize = 1, nBins = undefined) {
		let copy = [...arr];
		copy.sort(function (a, b) { return a - b }); //ascending sort
		let binStart = Math.min(...copy);
		if (typeof nBins === 'number') {
			let binEnd = Math.max(...copy);
			binSize = Math.abs((binEnd - binStart) / (nBins - 1));
		}
		let j = binStart;
		let binx = [];
		let biny = [];
		for (let i = 0; i < copy.length; i++) {
			let binidx = binSize * j;
			if (copy[i] > binStart + binidx) {
				j++;
				binidx += binSize;
				let binmin = binStart + binidx;
				let binmid = binmin + binidx * 0.5;
				binx.push(binmid);
				biny.push(0);
			}
			biny[biny.length - 1]++;
		}

		return [binx, biny];
	}


	//Get probability densities for the samples, set a cutoff to avoid obscenely small numbers
	static normalDistribution(samples = [], normalize = true, cutoff = 0.0001) {
		let m = this.mean(samples);
		let vari = this.variance(samples);
		let nSamples = samples.length;

		let probabilities = [];

		let denom = 1 / (this.TWO_PI * vari);
		let _variance = 1 / vari;
		let sum = 0; //for normalization
		for (let i = 0; i < nSamples; i++) {
			let px = Math.exp(-0.5 * Math.pow((samples[i] - m) * _variance, 2)) * denom
			if (px < cutoff) px = 0;
			probabilities.push(px);
			sum += px;
		}
		if (normalize) {
			let _sum = 1 / sum;
			probabilities = probabilities.map(x => x * _sum);
		}

		return probabilities;
	}

	static expectedValue(samples = [], probabilities = this.normalDistribution(samples)) {
		return samples.reduce((sum, item, idx) => sum + item * probabilities[idx]);
	}

	//moment about the origin (statistics)
	static originMoment(samples = [], probabilities = this.normalDistribution(samples), order = 1) {
		return samples.reduce((sum, item, idx) => sum + Math.pow(item, order) * probabilities[idx]);
	}

	//moment about the population mean (statistics)
	static centralMoment(samples = [], probabilities = this.normalDistribution(samples), order = 1) {
		let m = this.mean(samples);
		return samples.reduce((sum, item, idx) => sum + Math.pow((item - m), order) * probabilities[idx] / samples.length);
	}

	static linearDiscriminantAnalysis(samples = [], classifier = []) {
		let mean = this.mean(samples);
		let meank = this.mean(classifier);
		let covariance = this.cov1d(samples, classifier);
		let probs = this.normalDistribution(samples);

		let dk = [];
		for (let i = 0; i < samples.length; i++) {
			dk.push(x[i] * covariance * meank - .5 * mean * covariance * meank + Math.log10(probs[i]));
		}

		return dk;
	}

	//1D convolution (filtering)
	static conv1D(arr = [], kern = [1 / 3, 1 / 3, 1 / 3], pad = Math.floor(kern.length * 0.5)) {
		let result = [];
		let _n = 1 / kern.length;

		if (pad > 0) {
			let pads = new Array(pad).fill(0);
			arr = [...pads, ...arr, ...pads];
		}

		let start = Math.floor(kern.length * 0.5); //offset since kernel will reduce size of array
		let end = arr.length - kern.length + start; //end index

		for (let i = start; i < end; i++) {
			let acc = 0;
			for (let j = 0; j < kern.length; j++) {
				acc += arr[i - start] * kern[j];
			}
			result.push(acc * _n);
		}

		return result;
	}

	//2D convolution (filtering), input 2d mat and 2d kernel 
	static conv2D(mat = [[], [], []], kern = [[], [], []], pad = 0) {
		let result = new Array(mat.length - Math.ceil(kern.length * 0.5)).fill([]);

		let mat_t;
		let kern_t = Math2.transpose(kern_t);

		if (pad > 0) {
			let pads = new Array(pad).fill(0);

			//transpose to col/row
			mat_t = Math2.transpose(mat); //hard copy
			for (let i = 0; i < mat_t.length; i++) {
				mat_t[i] = [...pads, ...mat_t[i], ...pads];
			}

			//transpose back
			mat = Math2.transpose(mat_t);
			for (let j = 0; j < mat.length; j++) {
				mat[j] = [...pads, ...mat[j], ...pads];
			}

		}


		let startr = Math.floor(kern[0].length * 0.5); //offset since kernel will reduce size of array
		let startl = Math.floor(kern_t[0].length * 0.5); //offset since kernel will reduce size of array

		let endr = mat[0].length - kern[0].length + startr; //row end
		let endl = mat_t[0].length - kern_t[0].length + startl; //column end

		let _n = 1 / (kern[0].length * kern_t[0].length);

		let iters = endr * endl; //number of convolutions to perform

		let i = startr;
		let x; let y = startl;
		while (i < iters) {
			let acc = 0;
			x = i % mat[0].length;
			if (x === 0) {
				y++;
			}

			for (let j = 0; j < kern[0].length; j++) {
				for (let k = 0; k < kern_t[0].length; j++) {
					acc += mat[y - startl + k][x - startr + j] * kern[k][j];
				}

				result[y].push(acc * _n);
			}

			i++;
		}

		return result;

	}

	//2D matrix covariance (e.g. for lists of signals). Pretty fast!!!
	static cov2d(mat) { //[[x,y,z,w],[x,y,z,w],...] input list of vectors of the same length
		//Get variance of rows and columns
		//console.time("cov2d");
		var mattransposed = this.transpose(mat);
		//console.log(mattransposed)
		var matproducts = [];

		var rowmeans = [];
		var colmeans = [];

		mat.forEach((row, idx) => {
			rowmeans.push(this.mean(row));
		});

		mattransposed.forEach((col, idx) => {
			colmeans.push(this.mean(col));
		});

		mat.forEach((row, idx) => {
			matproducts.push([]);
			for (var col = 0; col < row.length; col++) {
				matproducts[idx].push((mat[idx][col] - rowmeans[idx]) * (mat[idx][col] - colmeans[col]) / (row.length - 1));
			}
		});

		/*
			mat[y][x] = (x - rowAvg)*(x - colAvg) / (mat[y].length - 1);
		*/

		//console.log(matproducts);
		//Transpose matrix
		var matproductstransposed = this.transpose(matproducts);

		//Matrix multiplication, stolen from: https://stackoverflow.com/questions/27205018/multiply-2-matrices-in-javascript
		var aNumRows = matproducts.length, aNumCols = matproducts[0].length,
			bNumRows = matproductstransposed.length, bNumCols = matproductstransposed[0].length,
			m = new Array(aNumRows);  // initialize array of rows
		for (var r = 0; r < aNumRows; ++r) {
			m[r] = new Array(bNumCols); // initialize the current row
			for (var c = 0; c < bNumCols; ++c) {
				m[r][c] = 0;             // initialize the current cell
				for (var i = 0; i < aNumCols; ++i) {
					m[r][c] += matproducts[r][i] * matproductstransposed[i][c] / (mat[0].length - 1); //divide by row length - 1
				}
			}
		}
		//console.timeEnd("cov2d");
		return m; //Covariance matrix
	}


	//Covariance between two 1D arrays
	static cov1d(arr1 = [], arr2 = []) {
		return this.cov2d([arr1, arr2]);
	}

	//3d covariance
	static cov3d(x = [], y = [], z = []) {
		return [
			[this.cov1d(x, x), this.cov1d(x, y), this.cov1d(x, z)],
			[this.cov1d(y, x), this.cov1d(y, y), this.cov1d(y, z)],
			[this.cov1d(z, x), this.cov1d(z, y), this.cov1d(z, z)]
		];
	}

	//n-dimensional covariance matrix
	static covNd(dimensionalData = []) {
		let covariance = [];
		dimensionalData.forEach((arr, i) => {
			covariance.push([]);
			dimensionalData.forEach((arr2, j) => {
				covariance[i].push(this.cov1d(arr, arr2));
			});
		});
	}

	//fast 2x2 eigenvalue calculator: https://www.youtube.com/watch?v=e50Bj7jn9IQ
	static eigens2x2(mat = [[1, 2], [3, 4]]) {
		let det = mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0];
		let mean = (mat[0][0] + mat[1][1]) * .5;

		let sqrt = Math.sqrt(mean * mean - det);
		let eig1 = mean + sqrt;
		let eig2 = mean - sqrt;

		return [eig1, eig2];
	}

	//http://math.colgate.edu/~wweckesser/math312Spring06/handouts/IMM_2x2linalg.pdf
	static eigenvectors2x2(mat = [[1, 2], [3, 4]], eigens = [1, 2]) {
		let v1 = [-mat[0][1], mat[0][0] - eigens[0]];
		if (v1[0] === 0 && v1[1] === 0) {
			v1[0] = mat[1][1] - eigens[0];
			v1[1] = -mat[1][0];
		}
		let v2 = [-mat[0][1], mat[0][0] - eigens[1]];
		if (v2[0] === 0 && v2[1] === 0) {
			v2[0] = mat[1][1] - eigens[1];
			v2[1] = -mat[1][0];
		}
		return [v1, v2];
	}

	//Fast PCA for 2D datasets https://towardsdatascience.com/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c
	static fastpca2d(xarr, yarr) {
		let cov1d = this.cov1d(xarr, yarr); //yields a 2x2 matrix
		let eigs = this.eigens2x2(cov1d);
		if (eigs[1] > eigs[0]) eigs.reverse();
		let evs = this.eigenvectors2x2(cov1d, eigs);

		console.log(eigs, evs)
		return [eigs, evs];
	}

	//Simple cross correlation.
	static crosscorrelation(arr1, arr2) {

		//console.time("crosscorrelation");
		var arr2buf = [...arr2, ...Array(arr2.length).fill(0)];
		var mean1 = this.mean(arr1);
		var mean2 = this.mean(arr2);

		//Estimators
		var arr1Est = arr1.reduce((sum, item) => sum += Math.pow(item - mean1, 2));
		arr1Est = Math.sqrt(Math.abs(arr1Est));
		var arr2Est = arr2.reduce((sum, item) => sum += Math.pow(item - mean1, 2));
		arr2Est = Math.sqrt(Math.abs(arr2Est));

		let denom = arr1Est * arr2Est;
		if(denom === 0) denom = 0.00000000000000000000000001;
		var _arrEstsMul = 1 / denom;
		var correlations = new Array(arr1.length).fill(0);

		for (var delay = 0; delay < arr1.length; delay++) {
			var r = arr1.reduce((sum, item, i) => sum += (item - mean1) * (arr2buf[delay + i] - mean2));
			correlations[delay] = r * _arrEstsMul;
		}

		//if(isNaN(correlations[0])) console.log(correlations,arr1Est,arr2Est,arr1,arr2);
		//console.timeEnd("crosscorrelation");
		return correlations;
	}

	//Simple autocorrelation. Better method for long series: FFT[x1] .* FFT[x2]
	static autocorrelation(arr1) {
		var delaybuf = [...arr1, ...Array(arr1.length).fill(0)];
		var mean1 = this.mean(arr1);

		//Estimators
		var arr1Est = arr1.reduce((sum, item) => sum += Math.pow(item - mean1, 2));
		arr1Est = Math.sqrt(Math.abs(arr1Est));

		let denom = arr1Est * arr2Est;
		if(denom === 0) denom = 0.00000000000000000000000001;

		var _arr1estsqrd = 1 / denom;
		var correlations = new Array(arr1.length).fill(0);

		for (var delay = 0; delay < arr1.length; delay++) {
			var r = arr1.reduce((sum, item, i) => sum += (item - mean1) * (delaybuf[delay + i] - mean1));
			correlations[delay] = r * _arr1estsqrd;
		}

		return correlations;
	}

	//pass a 2D array e.g image intensity, https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3414238/
	static autocorrelation2d = (mat2d) => {

		let result = [];
		for (let y = 0; y < mat2d.length; y++) {
			result.push([]); //push row
			for (let x = 0; x < mat2d[y].length; x++) {

				let G = 0;
				for (let b = 0; b < mat2d.length; b++) {
					for (let a = 0; a < mat2d[b].length; a++) {
						//console.log({x,y,a,b});
						G += mat2d[y][x] * mat2d[mat2d.length - 1 - b][mat2d[y].length - 1 - a];
					}
				}

				result[y][x] = G;
			}
		}

		return result;
	}


	static autocorrelation2dNormalized(mat2d) {
		let result = [];
		for (let y = 0; y < mat2d.length; y++) {
			result.push([]); //push row
			for (let x = 0; x < mat2d[y].length; x++) {

				let G = 0;
				let _G = 0;
				for (let b = 0; b < mat2d.length; b++) {
					for (let a = 0; a < mat2d[b].length; a++) {
						G += mat2d[y][x] * mat2d[mat2d.length - 1 - b][mat2d[y].length - 1 - a];
						_G += mat2d[y][x] * mat2d[mat2d.length - 1][mat2d[y].length - 1];
					}
				}

				result[y][x] = (G / _G) - 1;
			}
		}

		return result;
	}

	//pass a 2D array e.g image intensity, https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3414238/
	static crosscorrelation2d(mat2d1, mat2d2) {

		let result = [];
		for (let y = 0; y < mat2d1.length; y++) {
			result.push([]); //push row
			for (let x = 0; x < mat2d1[y].length; x++) {

				let G = 0;
				for (let b = 0; b < mat2d2.length; b++) {
					for (let a = 0; a < mat2d2[b].length; a++) {
						G += mat2d1[y][x] * mat2d2[mat2d2.length - 1 - b][mat2d2[y].length - 1 - a];
					}
				}

				result[y][x] = G;
			}
		}

		return result;
	}

	static crosscorrelation2dNormalized(mat2d1, mat2d2) {
		let result = [];
		for (let y = 0; y < mat2d1.length; y++) {
			result.push([]); //push row
			for (let x = 0; x < mat2d1[y].length; x++) {

				let G = 0;
				let _G = 0;
				for (let b = 0; b < mat2d2.length; b++) {
					for (let a = 0; a < mat2d2[b].length; a++) {
						G += mat2d1[y][x] * mat2d2[mat2d.length - 1 - b][mat2d2[y].length - 1 - a];
						_G += mat2d1[y][x] * mat2d2[mat2d2.length - 1][mat2d2[y].length - 1];
					}
				}

				result[y][x] = (G / _G) - 1;
			}
		}

		return result;
	}

	//Compute correlograms of the given array of arrays (of equal length). Input array of equal length arrays of latest raw data (use dat = eeg32instance.getTaggedRawData())
	static correlograms(dat = [[], []]) {//Coherence network math for data pushed to the atlas
		var correlograms = []; //auto and cross correlations for each channel
		dat.forEach((row1, i) => {
			dat.forEach((row2, j) => {
				if (j >= i) {
					correlograms.push(Math2.crosscorrelation(row1, row2));
				}
			})
		});
		return correlograms; //Output ordered like (tag1:tag1, tag1:tag2 ... tag2:tag2, tag2:tag3 ... tagn:tagn) where autocorrelograms are also included
	}

	//slow, only for example or really small sample sizes
	static dft(sineWave = []) {
		var TWOPI = 2 * 3.141592653589793;
		var real = [];
		var imag = [];
		var mags = [];
		//var maxFreq = sineWave.length/2;
		//var step = 0.25;
		//var freq = 0;
		for (var k = 0; k < sineWave.length; k++) {
			real.push(0);
			imag.push(0);
			for (var j = 0; j < sineWave.length; j++) {
				var shared = TWOPI * k * j / sineWave.length
				real[k] = real[k] + sineWave[j] * Math.cos(shared);
				imag[k] = imag[k] - sineWave[j] * Math.sin(shared);
			}
			mags.push(Math.sqrt(real[k] * real[k] + imag[k] * imag[k]));
		}

		//Order and sum positive magnitudes from bandpass DFT
		function orderMagnitudes(unorderedMags) {
			return [...unorderedMags.slice(Math.ceil(unorderedMags.length * .5), unorderedMags.length), ...unorderedMags.slice(0, Math.ceil(unorderedMags.length * .5))];
		}

		mags = orderMagnitudes(mags);
		let halflen = mags.length * 0.5;
		let freqs = mags.map((m, i) => {
			return i - halflen;
		})

		return {
			real,
			imag,
			freqs,
			mags
		}
	}


	//Input data and averaging window, output array of moving averages (should be same size as input array, initial values not fully averaged due to window)
	static sma(arr = [], window) {
		var smaArr = []; //console.log(arr);
		for (var i = 0; i < arr.length; i++) {
			if ((i == 0)) {
				smaArr.push(arr[0]);
			}
			else if (i < window) { //average partial window (prevents delays on screen)
				var arrslice = arr.slice(0, i + 1);
				smaArr.push(arrslice.reduce((previous, current) => current += previous) / (i + 1));
			}
			else { //average windows
				var arrslice = arr.slice(i - window, i);
				smaArr.push(arrslice.reduce((previous, current) => current += previous) / window);
			}
		}
		//console.log(temp);
		return smaArr;
	}

	static sum(arr = []) {
		if (arr.length > 0) {
			var sum = arr.reduce((prev, curr) => curr += prev);
			return sum;
		} else {
			return 0;
		}
	}

	static reduceArrByFactor(arr, factor = 2) { //faster than interpolating
		let x = arr.filter((element, index) => {
			return index % factor === 0;
		});
		return x;
	}

	//Make an array of size n from a to b 
	static makeArr(startValue, stopValue, nSteps) {
		var arr = [];
		var step = (stopValue - startValue) / (nSteps - 1);
		for (var i = 0; i < nSteps; i++) {
			arr.push(startValue + (step * i));
		}
		return arr;
	}

	static lerp = this.makeArr;

	//autoscale array between -1 and 1, can be used for stacking lines e.g. in webgl
	static autoscale(array, stackedLines = 1, stackPosition = 0, centerZero = false) {
		if (array?.length === 0) return array;
		let max = Math.max(...array)
		let min = Math.min(...array);

		let _lines = 1 / stackedLines;
		let scalar;
		if (centerZero) {
			let absmax = Math.max(Math.abs(min), Math.abs(max));
			scalar = _lines / absmax;
			return array.map(y => (y * scalar + (_lines * (stackPosition + 1) * 2 - 1 - _lines))); //scaled array
		}
		else {
			scalar = _lines / (max - min);
			return array.map(y => (2 * ((y - min) * scalar - (1 / (2 * stackedLines))) + (_lines * (stackPosition + 1) * 2 - 1 - _lines))); //scaled array
		}
	}


	//absolute value maximum of array (for a +/- valued array)
	static absmax(array) {
		return Math.max(Math.abs(Math.min(...array)), Math.max(...array));
	}

	//averages values when downsampling.
	static downsample(array, fitCount, scalar = 1) {

		if (array.length > fitCount) {
			let output = new Array(fitCount);
			let incr = array.length / fitCount;
			let lastIdx = array.length - 1;
			let last = 0;
			let counter = 0;
			for (let i = incr; i < array.length; i += incr) {
				let rounded = Math.round(i);
				if (rounded > lastIdx) rounded = lastIdx;
				for (let j = last; j < rounded; j++) {
					output[counter] += array[j];
				}
				output[counter] /= (rounded - last) * scalar;
				counter++;
				last = rounded;
			}
			return output;
		} else return array; //can't downsample a smaller array
	}

	//Linear interpolation from https://stackoverflow.com/questions/26941168/javascript-interpolate-an-array-of-numbers. Input array and number of samples to fit the data to
	static interpolateArray(data, fitCount, scalar = 1) {

		var linearInterpolate = function (before, after, atPoint) {
			return (before + (after - before) * atPoint) * scalar;
		};

		var newData = new Array();
		var springFactor = (data.length - 1) / (fitCount - 1);
		newData[0] = data[0]; // for new allocation
		for (var i = 1; i < fitCount - 1; i++) {
			var tmp = i * springFactor;
			var before = Math.floor(tmp);
			var after = Math.ceil(tmp);
			var atPoint = tmp - before;
			newData[i] = linearInterpolate(data[before], data[after], atPoint);
		}
		newData[fitCount - 1] = data[data.length - 1]; // for new allocation
		return newData;
	};

	static upsample = Math2.interpolateArray;

	//to create a linspace
	static lerp = (v0,v1,fit,floor=true) => {
				
		function lerp(v0, v1, t) {
			return ((1 - t) * v0) + (t * v1);
		}

		function interpolerp(v0,v1,fit, floor=true) {
			if(fit <= 2) return [v0, v1];
			let a = 1/fit;
			let result = new Array(fit);
			result[0] = v0;
			for(let i = 1; i <= fit; i++) {
				result[i] = lerp(v0,v1,a*i);
				if(floor) result[i] = Math.floor(result[i]);
			}
			return result;
		}

	}

	static isExtrema(arr, critical = 'peak') { //Checks if the middle point of the (odd-numbered) array is a local extrema. options: 'peak','valley','tangent'. Even numbered arrays are popped
		let ref = [...arr];
		if (ref.length % 2 === 0) ref.pop();
		if (arr.length > 1) {
			let pass = true;
			for (let i = 0; i < ref.length; i++) {
				let val = ref[i];
				if (critical === 'peak') { //search first derivative
					if (i < Math.floor(ref.length * .5) && val >= ref[Math.floor(ref.length * .5)]) {
						pass = false;
						break;
					} else if (i > Math.floor(ref.length * .5) && val >= ref[Math.floor(ref.length * .5)]) {
						pass = false;
						break;
					}
				} else if (critical === 'valley') { //search first derivative
					if (i < Math.floor(ref.length * .5) && val <= ref[Math.floor(ref.length * .5)]) {
						pass = false;
						break;
					} else if (i > Math.floor(ref.length * .5) && val <= ref[Math.floor(ref.length * .5)]) {
						pass = false;
						break;
					}
				} else { //look for tangents (best with 2nd derivative usually)
					if ((i < Math.floor(ref.length * .5) && val <= ref[Math.floor(ref.length * .5)])) {
						pass = false;
						break;
					} else if ((i > Math.floor(ref.length * .5) && val <= ref[Math.floor(ref.length * .5)])) {
						pass = false;
						break;
					}
				} //|| (i < ref.length*.5 && val <= 0 ) || (i > ref.length*.5 && val > 0)
			}
			if (critical !== 'peak' && critical !== 'valley' && pass === false) {
				pass = true;
				for (let i = 0; i < ref.length; i++) {
					let val = ref[i];
					if ((i < Math.floor(ref.length * .5) && val >= ref[Math.floor(ref.length * .5)])) {
						pass = false;
						break;
					} else if ((i > Math.floor(ref.length * .5) && val >= ref[Math.floor(ref.length * .5)])) {
						pass = false;
						break;
					}
				}
			}
			return pass;
		} else return undefined;
	}

	static isCriticalPoint(arr, critical = 'peak') { //Checks if the middle point of the (odd-numbered) array is a critical point. options: 'peak','valley','tangent'. Even numbered arrays are popped
		let ref = [...arr];
		if (ref.length % 2 === 0) ref.pop();
		if (arr.length > 1) {
			let pass = true;
			for (let i = 0; i < ref.length; i++) {
				let val = ref[i];
				if (critical === 'peak') { //search first derivative
					if (i < ref.length * .5 && val <= 0) {
						pass = false;
						break;
					} else if (i > ref.length * .5 && val > 0) {
						pass = false;
						break;
					}
				} else if (critical === 'valley') { //search first derivative
					if (i < ref.length * .5 && val >= 0) {
						pass = false;
						break;
					} else if (i > ref.length * .5 && val < 0) {
						pass = false;
						break;
					}
				} else { //look for tangents (best with 2nd derivative usually)
					if ((i < ref.length * .5 && val >= 0)) {
						pass = false;
						break;
					} else if ((i > ref.length * .5 && val < 0)) {
						pass = false;
						break;
					}
				}
			}
			if (critical !== 'peak' && critical !== 'valley' && pass === false) {
				pass = true;
				for (let i = 0; i < ref.length; i++) {
					let val = ref[i];
					if ((i < ref.length * .5 && val <= 0)) {
						pass = false;
						break;
					} else if ((i > ref.length * .5 && val > 0)) {
						pass = false;
						break;
					}
				}
			}
			return pass;
		} else return undefined;
	}

	//returns array of indices of detected peaks/valleys
	static peakDetect = (smoothedArray, type = 'peak', window = 49) => {
		let mid = Math.floor(window * .5);
		let peaks = [];
		//console.log(smoothedArray.length-window)
		for (let i = 0; i < smoothedArray.length - window; i++) {
			let isPeak = this.isExtrema(smoothedArray.slice(i, i + window), type);
			if (isPeak) {
				peaks.push(i + mid - 1);
			}
		}
		return peaks;
	}

	//gets a mean threshold based on peaks in an array
	static getPeakThreshold(arr, peakIndices, thresholdVar) {
		let threshold;
		let filtered = arr.filter((o, i) => { if (peakIndices.indexOf(i) > -1) return true; });
		if (thresholdVar === 0) {
			threshold = this.mean(filtered);
		} else threshold = (thresholdVar + this.mean(filtered)) * 0.5;

		return threshold;
	}

	//-------------------------------------------------------------



	//The following n-dimensional Eigenvalue/PCA Math was adapted from: https://github.com/johnmihalik/eigenvector/blob/master/pca.js
	static column(mat, x) {
		let col = new Array(mat.length).fill(0).map(() => new Array(1).fill(0));
		for (let i = 0; i < mat.length; i++) {
			col[i][0] = mat[i][x];
		}
		return col;
	}

	//flatten a vector of 1-value vectors
	static flatten_vector(v) {
		let v_new = [];
		for (let i = 0; i < v.length; i++) {
			v_new[i] = v[i][0];
		}
		return v_new;
	}

	static squared_difference(v1, v2) {
		let sum = 0.0;
		for (let i = 0; i < v1.length; i++) {
			sum = sum + Math.pow(v1[i] - v2[i], 2);
		}
		return sum;
	}

	// See: https://math.stackexchange.com/questions/768882/power-method-for-finding-all-eigenvectors
	static shift_deflate(mat, eigenvalue, eigenvector) {
		let len = Math.sqrt(this.matmul(this.transpose(eigenvector), eigenvector));
		let U = this.matscale(eigenvector, 1.0 / len);
		let delta = this.matscale(this.matmul(U, this.transpose(U)), eigenvalue);
		let M_new = this.matsub(mat, delta);
		return M_new;
	}

	static eigenvalue_of_vector(mat, eigenvector) {
		// Xt * M * x
		ev = this.matmul(this.matmul(this.transpose(eigenvector), mat), eigenvector);
		return ev;
	}

	//Input square 2D matrix
	static power_iteration(mat, tolerance = 0.00001, max_iterations = 1000) {

		let rank = mat.length;

		// Initialize the first guess pf the eigenvector to a row vector of the sqrt of the rank
		let eigenvector = new Array(rank).fill(0).map(() => new Array(1).fill(Math.sqrt(rank)));

		// Compute the corresponding eigenvalue
		let eigenvalue = this.eigenvalue_of_vector(mat, eigenvector);

		let epsilon = 1.0;
		let iter = 0;
		while (epsilon > tolerance && iter < max_iterations) {

			let old_eigenvalue = JSON.parse(JSON.stringify(eigenvalue));

			// Multiply the Matrix M by the guessed eigenveector
			let Mv = this.matmul(mat, eigenvector);

			// Normalize the eigenvector to unit length
			eigenvector = this.normalize(Mv);

			// Calculate the associated eigenvalue with the eigenvector (transpose(v) * M * v)
			eigenvalue = this.eigenvalue_of_vector(mat, eigenvector);

			// Calculate the epsilon of the differences
			epsilon = Math.abs(eigenvalue - old_eigenvalue);
			iter++;

		};

		return [eigenvalue, eigenvector];
	}

	//Input square 2D matrix
	static eigens(mat, tolerance = 0.0001, max_iterations = 1000) {

		let eigenvalues = [];
		let eigenvectors = [];

		for (let i = 0; i < mat.length; i++) {

			// Compute the remaining most prominent eigenvector of the matrix M
			let result = this.power_iteration(mat, tolerance, max_iterations);

			// Separate the eigenvalue and vector from the return array
			let eigenvalue = result[0];
			let eigenvector = result[1];

			eigenvalues[i] = eigenvalue;
			eigenvectors[i] = this.flatten_vector(eigenvector);

			// Now remove or peel off the last eigenvector
			mat = this.shift_deflate(mat, eigenvalue, eigenvector);
		}

		return [eigenvalues, eigenvectors];
	}

	//Input square 2D matrix. For eeg data you input a square covariance matrix of the signal data (or the z-scores of the signal data)
	static pca(mat, tolerance = 0.00001) {
		let dims = mat.length;

		let t = new Array(dims);
		let p = new Array(dims);

		let mat_t = this.transpose(mat);
		t[0] = this.column(mat, 0);
		let epsilon = 1.0;
		let iter = 0;

		while (espilon > tolerance) {
			iter++;
			p[0] = this.matmul(mat_t, t[0]);
			let tp = this.matmul(this.transpose(t[0]), t[0]);
			p[0] = this.matscale(p[0], 1.0 / tp);

			// Normalize p
			let p_length = Math.sqrt(this.matmul(this.transpose(p[0]), p[0]));
			p[0] = this.matscale(p[0], 1.0 / p_length);

			let t_new = this.matmul(mat, p[0]);
			let pp = this.matmul(this.transpose(p[0]), p[0]);
			t_new = this.matscale(t_new, 1.0 / pp);

			epsilon = this.squared_difference(t[0], t_new);

			t[0] = JSON.parse(JSON.stringify(t_new));
		}

		let components = this.matmul(this.transpose(t[0]), t[0]);

		return components;
	}

	//push new entries to end of array and roll over starting entries with a set array length
    static circularBuffer(arr,newEntries) {
        if(Array.isArray(newEntries)) {
            if(newEntries.length < arr.length) {
                let slice = arr.slice(newEntries.length);
                let len = arr.length;
                arr.splice(
                    0,
                    len,
                    ...slice,...newEntries
                );
            }
            else if (newEntries.length > arr.length) {
                let len = arr.length;
                arr.splice(
                    0,
                    len,
                    newEntries.slice(len-newEntries.length)
                );
            }
            else { 
                arr.splice(0,arr.length,...newEntries);
            }
        } else {
            arr.push(newEntries); 
            arr.shift();
        }
        
        return arr;
    }

	static HSLToRGB(h,s,l, scalar=255) {
        // Must be fractions of 1
        s /= 100;
        l /= 100;
      
        let c = (1 - Math.abs(2 * l - 1)) * s,
            x = c * (1 - Math.abs((h / 60) % 2 - 1)),
            m = l - c/2,
            r = 0,
            g = 0,
            b = 0;
     
        if (0 <= h && h < 60) {
            r = c; g = x; b = 0;  
        } else if (60 <= h && h < 120) {
            r = x; g = c; b = 0;
        } else if (120 <= h && h < 180) {
            r = 0; g = c; b = x;
        } else if (180 <= h && h < 240) {
            r = 0; g = x; b = c;
        } else if (240 <= h && h < 300) {
            r = x; g = 0; b = c;
        } else if (300 <= h && h < 360) {
            r = c; g = 0; b = x;
        }
        r = (r + m) * scalar;
        g = (g + m) * scalar;
        b = (b + m) * scalar;

        return [r,g,b];
    }

	//-------------------------------------------------------------

	//pass in 1 second of raw data ish recommended, desired event timestamps and signals are ordered from least current to most current 
	static p300(event_timestamps = [], raw_signal = [], signal_timestamps = [], sps = 256) {
		let smoothingstep = Math.floor(sps / 10); //300ms width peak, 1/10th sec smoothing for filtering
		let smoothed = this.sma(raw_signal, smoothingstep);
		let peaks = this.peakDetect(smoothed, 'peak', smoothingstep); //returns indices of peaks
		let mean = this.mean(smoothed);
		let std = this.std(smoothed, mean);

		let p_idx = 0;
		let candidates = [];
		if (peaks.length > 0) {
			event_timestamps.forEach((t, j) => {
				while (signal_timestamps[peaks[p_idx]] < t + 200) { //roll over peaks that are behind of the latest event + 200ms
					p_idx++;
					if (!peaks[p_idx]) break;
				}

				let tempi = 0;
				let tempcandidates = [];
				while (signal_timestamps[peaks[p_idx + tempi]] < t + 600) { //get peaks that are behind the latest event + (200ms-600ms)
					tempcandidates.push(p_idx + tempi);
					tempi++;
					if (!peaks[p_idx + tempi]) break;
				}
				if (tempcandidates.length > 1) { //if multiple peaks found choose the biggest one for the main p300 peak (not worrying about p1,p2,n1,n2 yet)
					let peakvals = [];
					tempcandidates.forEach((tc) => {
						peakvals.push(smoothed[peaks[tc]]);
					});
					let max = Math.max(...peakvals);
					let maxi = tempcandidates[peakvals.indexOf(max)];

					candidates.push({
						event_timestamp: t,
						event_index: j,
						peak_timestamp: signal_timestamps[[peaks[maxi]]],
						signal_index: [peaks[maxi]],
						signal_amplitude: raw_signal[[peaks[maxi]]],
						zscore: (smoothed[peaks[maxi]] - mean) / std //significance measure
					});
				} else if (tempcandidates.length === 1) candidates.push({
					event_timestamp: t,
					event_index: j,
					peak_timestamp: signal_timestamps[peaks[tempcandidates[0]]],
					signal_index: peaks[tempcandidates[0]],
					signal_amplitude: raw_signal[[peaks[tempcandidates[0]]]],
					zscore: (smoothed[peaks[tempcandidates[0]]] - mean) / std //significance measure

				});
			});
		} return candidates;
	}

}

Object.assign(Math, Math2); //get it on the math object