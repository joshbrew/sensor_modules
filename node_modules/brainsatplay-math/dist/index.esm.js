var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// Math2.js
var _Math2 = class {
  constructor() {
  }
  static genSineWave(freq = 20, peakAmp = 1, nSec = 1, fs = 512, freq2 = 0, peakAmp2 = 1) {
    var sineWave = [];
    var t = [];
    var increment = 1 / fs;
    for (var ti = 0; ti < nSec; ti += increment) {
      var amplitude = Math.sin(2 * Math.PI * freq * ti) * peakAmp;
      amplitude += Math.sin(2 * Math.PI * freq2 * ti) * peakAmp2;
      sineWave.push(amplitude);
      t.push(ti);
    }
    return [t, sineWave];
  }
  static getSineAmplitude(frequency = 20, peakAmplitude = 1, ti = 0, tOffset = 0) {
    return Math.sin(this.TWO_PI * frequency * ti + tOffset) * peakAmplitude;
  }
  static mean(arr) {
    var sum = arr.reduce((prev, curr) => curr += prev);
    return sum / arr.length;
  }
  static mode(arr) {
    return arr.sort(
      (a, b) => arr.filter((v) => v === a).length - arr.filter((v) => v === b).length
    ).pop();
  }
  static std(arr, mean = void 0) {
    let avg = mean;
    if (!mean)
      avg = this.mean(arr);
    let summed = 0;
    for (let i = 0; i < arr.length; i++) {
      let subbed = arr[i] - avg;
      summed += subbed * subbed;
    }
    return Math.sqrt(summed / arr.length);
  }
  static relError(actual = [], forecast = [], abs = true) {
    if (actual.length !== forecast.length)
      throw new Error("Input arrays of same length!");
    let i = actual.length;
    let d = new Array(actual.length);
    for (let j = 0; j < i; j++) {
      let dd = (actual[j] - forecast[j]) / actual[j];
      if (abs)
        dd = Math.abs(dd);
      d[j] = dd;
    }
    return d;
  }
  static informationEntropy(probabilities = []) {
    let len = probabilities.length;
    let entropy = new Array(len);
    for (let i = 0; i < len; i++) {
      let ent = probabilities[i] * Math.log(probabilities[i]);
      if (isNaN(ent))
        ent = 0;
      entropy[i] = ent;
    }
    return entropy;
  }
  static zscore(arr) {
    let mean = this.mean(arr);
    let std = this.std(arr, mean);
    let z = new Array().length(arr.length);
    for (let i = 0; i < arr.length; i++) {
      z[i] = (arr[i] - mean) / std;
    }
    return z;
  }
  static variance(arr) {
    var mean = this.mean(arr);
    return arr.reduce((a, b) => a + (b - mean) ** 2, 0) / arr.length;
  }
  static dot(vec1, vec2) {
    var dot = 0;
    for (var i = 0; i < vec1.length; i++) {
      dot += vec1[i] * vec2[i];
    }
    return dot;
  }
  static cross3D(vec1, vec2) {
    return [
      vec1[1] * vec2[2] - vec1[2] * vec2[1],
      vec1[2] * vec2[0] - vec1[0] * vec2[2],
      vec1[0] * vec2[1] - vec1[1] * vec2[0]
    ];
  }
  static magnitude(vec) {
    var sqrd = 0;
    vec.forEach((c) => {
      sqrd += c * c;
    });
    return Math.sqrt(sqrd);
  }
  static distance(point1, point2) {
    var dsqrd = 0;
    point1.forEach((c, i) => {
      dsqrd += (point2[i] - c) * (point2[i] - c);
    });
    return Math.sqrt(dsqrd);
  }
  static midpoint(point1 = [1, 2, 3], point2 = [3, 4, 5]) {
    return point1.map((c, i) => {
      return (c + point2[i]) * 0.5;
    });
  }
  static normalize(vec) {
    var norm = 0;
    norm = this.magnitude(vec);
    var vecn = new Array(vec.length);
    vec.forEach((c, i) => {
      vecn[i] = c * norm;
    });
    return vecn;
  }
  static normalizeSeries(arr = [], fromZero = true) {
    let max = Math.max(...arr);
    let min = Math.min(...arr);
    if (fromZero == false) {
      max = Math.max(max, Math.abs(min));
      min = 0;
    }
    if (max - min === 0) {
      min = 0;
      if (max === 0)
        max = 1e-13;
    }
    return arr.map((v) => (v - min) / (max - min));
  }
  static quadraticFormula(a, b, c) {
    let bbmac4 = Math.sqrt(b * b - 4 * a * c);
    if (!isNaN(bbmac4))
      return ["complex", "complex"];
    let _a2 = 1 / (2 * a);
    if (bbmac4 === 0)
      return [b * _a2];
    let nb = -b;
    return [(nb + bbmac4) * _a2, (nb - bbmac4) * _a2];
  }
  static newtonsMethod(foo = (x2) => {
    return Math.pow(x2, 5) + x2 * x2 - x2 - 0.2;
  }, start = 0, end = 1, precision = 0.01, attempts = 10) {
    let roots = [];
    for (let i = 0; i < attempts; i++) {
      let seedx = Math.random() * (end - start);
      let guess = foo(seedx);
      let guess2 = foo(seedx + precision);
      let slope = (guess2 - guess) / precision;
      let xn = seedx + precision;
      while (Math.abs(slope) > precision) {
        let step = -guess / slope2;
        let xn12 = xn + step;
        guess = guess2;
        guess2 = foo(xn12);
        let slope2 = (guess2 - guess) / (xn12 - xn);
      }
      let idx;
      let f = roots.find((root, i2) => {
        if (Math.abs(xn1 - root) < precision) {
          idx = i2;
          return true;
        }
      });
      if (f)
        roots[idx] = (xn1 + f) * 0.5;
      else
        roots.push(xn1);
    }
    return roots;
  }
  static makeVec(point1, point2) {
    var vec = [];
    point1.forEach((c, i) => {
      vec.push(point2[i] - c);
    });
    return vec;
  }
  static getBufferedValueByCoordinates(vb = new Array(300).fill(1), dims = [10, 10, 2], coordinate = [1, 2, 1], cardinal = void 0) {
    let getIdx = (foundIdx = 0, dimIdx = 0) => {
      if (dimIdx === dims.length)
        return foundIdx;
      if (dimIdx == 0)
        foundIdx += coordinate[dimIdx];
      else if (dims[dimIdx] == 0)
        dimsAt0++;
      else {
        let reMul = (val = coordinate[dimIdx], di = dimIdx - 1) => {
          val *= dims[di];
          di--;
          if (di == 0)
            return val;
          else
            return reMul(val, di);
        };
        foundIdx += reMul(coordinate[dimIdx] + 1, dimIdx - 1);
      }
      dimIdx++;
      return getIdx(foundIdx, dimIdx);
    };
    let found = getIdx();
    if (cardinal) {
      if (coordinate[coordinate.length - 1] === 0) {
        let lastnonzero = 0;
        let idx = 0;
        while (idx !== coordinate.length - 1) {
          if (coordinate[idx] !== 0)
            lastnonzero = idx;
          idx++;
        }
        return vb[found - lastnonzero + cardinal];
      }
      return vb[found - dims.length + cardinal];
    } else {
      if (coordinate[coordinate.length - 1] === 0) {
        let lastnonzero = 0;
        let idx = 0;
        while (idx !== coordinate.length - 1) {
          if (coordinate[idx] !== 0)
            lastnonzero = idx;
          idx++;
        }
        return vb.slice(found - lastnonzero, found + 1);
      }
      return vb.slice(found - dims.length, found + 1);
    }
  }
  static forBufferedMat(vb = new Array(100).fill(1), dims = [10, 10], asIndex = (v, i, x2, y) => {
    return v + x2 + y;
  }) {
    let coordinate = [];
    let idx = 0;
    let recurseFor = (depth = 0, nextDepth = depth + 1) => {
      let result = new Array(vb.length);
      for (let di = 0; di < dims[depth]; di++) {
        coordinate[depth] = di;
        if (dims[nextDepth])
          recurseFor(nextDepth);
        else {
          result[idx] = asIndex(vb[idx], idx, ...coordinate);
          idx++;
        }
      }
      return result;
    };
    let recurseForArrFuncs = (depth, nextDepth = depth + 1) => {
      let result = new Array(vb.length);
      for (let di = 0; di < dims[depth]; di++) {
        coordinate[depth] = di;
        if (dims[nextDepth])
          recurseFor(nextDepth);
        else {
          for (let dj = 0; dj < dims.length; dj++) {
            result[idx] = asIndex[dj](vb[idx], idx, ...coordinate);
            idx++;
          }
        }
      }
      return result;
    };
    if (typeof asIndex === "function") {
      return recurseFor();
    } else if (Array.isArray(asIndex)) {
      return recurseForArrFuncs();
    }
  }
  static mapBufferedMat(buffer = new Array(100).fill(1), dimensions = [10, 10], asIndex = (v, idx, i, j) => {
    console.log(`value:${v}, idx:${idx}, x:${i},y:${j}`);
    return v + i + j;
  }) {
    let coordinate = new Array(dimensions.length).fill(0);
    const iterateCoordinate = (coord, idx = 0) => {
      if (coord[idx] >= dimensions[idx]) {
        coord[idx] = 0;
        idx++;
        if (idx === dimensions.length)
          return;
        iterateCoordinate(coord, idx);
      } else
        coord[idx]++;
    };
    let result = new Array(buffer.length);
    let i = 0;
    if (typeof asIndex === "function") {
      while (i < buffer.length) {
        result[i] = asIndex(buffer[i], i, ...coordinate);
        i += dimensions.length;
        iterateCoordinate(coordinate);
      }
    } else if (Array.isArray(asIndex)) {
      while (i < buffer.length) {
        asIndex.forEach((func) => {
          result[i] = func(buffer[i], i, ...coordinate);
          i++;
          iterateCoordinate(coordinate);
        });
      }
    }
    return result;
  }
  static combinations(choices = ["a", "b", "c"], vecsize = 3) {
    var result = [];
    if (vecsize <= 0) {
      result.push([]);
    } else {
      _Math2.combinations(choices, vecsize - 1).forEach(function(previousComb) {
        choices.forEach(function(element) {
          result.push([element].concat(previousComb));
        });
      });
    }
    return result;
  }
  static generateCoordinateSpace(upperBounds = [10, 10, 10], lowerBounds = [-10, -10, -10], steps = [1, 1, 1], mutater = void 0) {
    for (let i = 0; i < upperBounds.length; i++) {
      if (lowerBounds[i] > upperBounds[i]) {
        let temp = upperBounds[i];
        upperBounds[i] = lowerBounds[i];
        lowerBounds[i] = temp;
      }
    }
    let result = [];
    let copy = [...upperBounds];
    let lastindex = copy.length - 1;
    result.push([...copy]);
    while (copy[0] >= lowerBounds[0]) {
      let checkNextIndex = (decrIdx2) => {
        if (copy[decrIdx2] <= lowerBounds[decrIdx2]) {
          if (decrIdx2 === 0)
            return;
          copy[decrIdx2] = upperBounds[decrIdx2];
          decrIdx2--;
          if (decrIdx2 < 0)
            return;
          if (typeof steps[decrIdx2] == "function")
            copy[decrIdx2] -= steps[decrIdx2](copy[decrIdx2]);
          else
            copy[decrIdx2] -= steps[decrIdx2];
          checkNextIndex(decrIdx2);
        }
      };
      let decrIdx = lastindex;
      if (typeof steps[decrIdx] == "function")
        copy[decrIdx] -= steps[decrIdx](copy[decrIdx]);
      else
        copy[decrIdx] -= steps[decrIdx];
      result.push([...copy]);
      checkNextIndex(decrIdx);
      if (mutater)
        result[result.length - 1] = mutater(result[result.length - 1]);
    }
    return result;
  }
  static calcVectorField(coordinates = [[0, 0], [0, 1], [1, 0], [1, 1]], formula = (x2, y) => {
    return [x2 * 10, y * 10];
  }) {
    return coordinates.map((vec) => formula(...vec));
  }
  static transpose(mat) {
    return mat[0].map((_, colIndex) => mat.map((row) => row[colIndex]));
  }
  static matmul(a, b) {
    var aNumRows = a.length, aNumCols = a[0].length, bNumRows = b.length, bNumCols = b[0].length, m = new Array(aNumRows);
    for (var r = 0; r < aNumRows; ++r) {
      m[r] = new Array(bNumCols);
      for (var c = 0; c < bNumCols; ++c) {
        m[r][c] = 0;
        for (var i = 0; i < aNumCols; ++i) {
          m[r][c] += a[r][i] * b[i][c];
        }
      }
    }
    return m;
  }
  static matscale(mat, scalar) {
    let m = [];
    for (var i = 0; i < mat.length; i++) {
      m[i] = [];
      for (let j = 0; j < mat[0].length; j++) {
        m[i][j] = mat[i][j] * scalar;
      }
    }
    return m;
  }
  static matadd(a, b) {
    let m = [];
    for (let i = 0; i < a.length; i++) {
      m[i] = [];
      for (var j = 0; j < a[0].length; j++) {
        m[i][j] = a[i][j] + b[i][j];
      }
    }
    return m;
  }
  static matsub(a, b) {
    let m = [];
    for (let i = 0; i < a.length; i++) {
      m[i] = [];
      for (var j = 0; j < a[0].length; j++) {
        m[i][j] = a[i][j] - b[i][j];
      }
    }
    return m;
  }
  static histogram(arr = [], binSize = 1, nBins = void 0) {
    let copy = [...arr];
    copy.sort(function(a, b) {
      return a - b;
    });
    let binStart = Math.min(...copy);
    if (typeof nBins === "number") {
      let binEnd = Math.max(...copy);
      binSize = Math.abs((binEnd - binStart) / (nBins - 1));
    }
    let j = binStart;
    let binx = [];
    let biny = [];
    for (let i = 0; i < copy.length; i++) {
      let binidx = binSize * j;
      if (copy[i] > binStart + binidx) {
        j++;
        binidx += binSize;
        let binmin = binStart + binidx;
        let binmid = binmin + binidx * 0.5;
        binx.push(binmid);
        biny.push(0);
      }
      biny[biny.length - 1]++;
    }
    return [binx, biny];
  }
  static normalDistribution(samples = [], normalize = true, cutoff = 1e-4) {
    let m = this.mean(samples);
    let vari = this.variance(samples);
    let nSamples = samples.length;
    let probabilities = [];
    let denom = 1 / (this.TWO_PI * vari);
    let _variance = 1 / vari;
    let sum = 0;
    for (let i = 0; i < nSamples; i++) {
      let px = Math.exp(-0.5 * Math.pow((samples[i] - m) * _variance, 2)) * denom;
      if (px < cutoff)
        px = 0;
      probabilities.push(px);
      sum += px;
    }
    if (normalize) {
      let _sum = 1 / sum;
      probabilities = probabilities.map((x2) => x2 * _sum);
    }
    return probabilities;
  }
  static expectedValue(samples = [], probabilities = this.normalDistribution(samples)) {
    return samples.reduce((sum, item, idx) => sum + item * probabilities[idx]);
  }
  static originMoment(samples = [], probabilities = this.normalDistribution(samples), order = 1) {
    return samples.reduce((sum, item, idx) => sum + Math.pow(item, order) * probabilities[idx]);
  }
  static centralMoment(samples = [], probabilities = this.normalDistribution(samples), order = 1) {
    let m = this.mean(samples);
    return samples.reduce((sum, item, idx) => sum + Math.pow(item - m, order) * probabilities[idx] / samples.length);
  }
  static linearDiscriminantAnalysis(samples = [], classifier = []) {
    let mean = this.mean(samples);
    let meank = this.mean(classifier);
    let covariance = this.cov1d(samples, classifier);
    let probs = this.normalDistribution(samples);
    let dk = [];
    for (let i = 0; i < samples.length; i++) {
      dk.push(x[i] * covariance * meank - 0.5 * mean * covariance * meank + Math.log10(probs[i]));
    }
    return dk;
  }
  static conv1D(arr = [], kern = [1 / 3, 1 / 3, 1 / 3], pad = Math.floor(kern.length * 0.5)) {
    let result = [];
    let _n = 1 / kern.length;
    if (pad > 0) {
      let pads = new Array(pad).fill(0);
      arr = [...pads, ...arr, ...pads];
    }
    let start = Math.floor(kern.length * 0.5);
    let end = arr.length - kern.length + start;
    for (let i = start; i < end; i++) {
      let acc = 0;
      for (let j = 0; j < kern.length; j++) {
        acc += arr[i - start] * kern[j];
      }
      result.push(acc * _n);
    }
    return result;
  }
  static conv2D(mat = [[], [], []], kern = [[], [], []], pad = 0) {
    let result = new Array(mat.length - Math.ceil(kern.length * 0.5)).fill([]);
    let mat_t;
    let kern_t = _Math2.transpose(kern_t);
    if (pad > 0) {
      let pads = new Array(pad).fill(0);
      mat_t = _Math2.transpose(mat);
      for (let i2 = 0; i2 < mat_t.length; i2++) {
        mat_t[i2] = [...pads, ...mat_t[i2], ...pads];
      }
      mat = _Math2.transpose(mat_t);
      for (let j = 0; j < mat.length; j++) {
        mat[j] = [...pads, ...mat[j], ...pads];
      }
    }
    let startr = Math.floor(kern[0].length * 0.5);
    let startl = Math.floor(kern_t[0].length * 0.5);
    let endr = mat[0].length - kern[0].length + startr;
    let endl = mat_t[0].length - kern_t[0].length + startl;
    let _n = 1 / (kern[0].length * kern_t[0].length);
    let iters = endr * endl;
    let i = startr;
    let x2;
    let y = startl;
    while (i < iters) {
      let acc = 0;
      x2 = i % mat[0].length;
      if (x2 === 0) {
        y++;
      }
      for (let j = 0; j < kern[0].length; j++) {
        for (let k = 0; k < kern_t[0].length; j++) {
          acc += mat[y - startl + k][x2 - startr + j] * kern[k][j];
        }
        result[y].push(acc * _n);
      }
      i++;
    }
    return result;
  }
  static cov2d(mat) {
    var mattransposed = this.transpose(mat);
    var matproducts = [];
    var rowmeans = [];
    var colmeans = [];
    mat.forEach((row, idx) => {
      rowmeans.push(this.mean(row));
    });
    mattransposed.forEach((col, idx) => {
      colmeans.push(this.mean(col));
    });
    mat.forEach((row, idx) => {
      matproducts.push([]);
      for (var col = 0; col < row.length; col++) {
        matproducts[idx].push((mat[idx][col] - rowmeans[idx]) * (mat[idx][col] - colmeans[col]) / (row.length - 1));
      }
    });
    var matproductstransposed = this.transpose(matproducts);
    var aNumRows = matproducts.length, aNumCols = matproducts[0].length, bNumRows = matproductstransposed.length, bNumCols = matproductstransposed[0].length, m = new Array(aNumRows);
    for (var r = 0; r < aNumRows; ++r) {
      m[r] = new Array(bNumCols);
      for (var c = 0; c < bNumCols; ++c) {
        m[r][c] = 0;
        for (var i = 0; i < aNumCols; ++i) {
          m[r][c] += matproducts[r][i] * matproductstransposed[i][c] / (mat[0].length - 1);
        }
      }
    }
    return m;
  }
  static cov1d(arr1 = [], arr2 = []) {
    return this.cov2d([arr1, arr2]);
  }
  static cov3d(x2 = [], y = [], z = []) {
    return [
      [this.cov1d(x2, x2), this.cov1d(x2, y), this.cov1d(x2, z)],
      [this.cov1d(y, x2), this.cov1d(y, y), this.cov1d(y, z)],
      [this.cov1d(z, x2), this.cov1d(z, y), this.cov1d(z, z)]
    ];
  }
  static covNd(dimensionalData = []) {
    let covariance = [];
    dimensionalData.forEach((arr, i) => {
      covariance.push([]);
      dimensionalData.forEach((arr2, j) => {
        covariance[i].push(this.cov1d(arr, arr2));
      });
    });
  }
  static eigens2x2(mat = [[1, 2], [3, 4]]) {
    let det = mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0];
    let mean = (mat[0][0] + mat[1][1]) * 0.5;
    let sqrt = Math.sqrt(mean * mean - det);
    let eig1 = mean + sqrt;
    let eig2 = mean - sqrt;
    return [eig1, eig2];
  }
  static eigenvectors2x2(mat = [[1, 2], [3, 4]], eigens = [1, 2]) {
    let v1 = [-mat[0][1], mat[0][0] - eigens[0]];
    if (v1[0] === 0 && v1[1] === 0) {
      v1[0] = mat[1][1] - eigens[0];
      v1[1] = -mat[1][0];
    }
    let v2 = [-mat[0][1], mat[0][0] - eigens[1]];
    if (v2[0] === 0 && v2[1] === 0) {
      v2[0] = mat[1][1] - eigens[1];
      v2[1] = -mat[1][0];
    }
    return [v1, v2];
  }
  static fastpca2d(xarr, yarr) {
    let cov1d = this.cov1d(xarr, yarr);
    let eigs = this.eigens2x2(cov1d);
    if (eigs[1] > eigs[0])
      eigs.reverse();
    let evs = this.eigenvectors2x2(cov1d, eigs);
    console.log(eigs, evs);
    return [eigs, evs];
  }
  static crosscorrelation(arr1, arr2) {
    var arr2buf = [...arr2, ...Array(arr2.length).fill(0)];
    var mean1 = this.mean(arr1);
    var mean2 = this.mean(arr2);
    var arr1Est = arr1.reduce((sum, item) => sum += Math.pow(item - mean1, 2));
    arr1Est = Math.sqrt(Math.abs(arr1Est));
    var arr2Est2 = arr2.reduce((sum, item) => sum += Math.pow(item - mean1, 2));
    arr2Est2 = Math.sqrt(Math.abs(arr2Est2));
    let denom = arr1Est * arr2Est2;
    if (denom === 0)
      denom = 1e-26;
    var _arrEstsMul = 1 / denom;
    var correlations = new Array(arr1.length).fill(0);
    for (var delay = 0; delay < arr1.length; delay++) {
      var r = arr1.reduce((sum, item, i) => sum += (item - mean1) * (arr2buf[delay + i] - mean2));
      correlations[delay] = r * _arrEstsMul;
    }
    return correlations;
  }
  static autocorrelation(arr1) {
    var delaybuf = [...arr1, ...Array(arr1.length).fill(0)];
    var mean1 = this.mean(arr1);
    var arr1Est = arr1.reduce((sum, item) => sum += Math.pow(item - mean1, 2));
    arr1Est = Math.sqrt(Math.abs(arr1Est));
    let denom = arr1Est * arr2Est;
    if (denom === 0)
      denom = 1e-26;
    var _arr1estsqrd = 1 / denom;
    var correlations = new Array(arr1.length).fill(0);
    for (var delay = 0; delay < arr1.length; delay++) {
      var r = arr1.reduce((sum, item, i) => sum += (item - mean1) * (delaybuf[delay + i] - mean1));
      correlations[delay] = r * _arr1estsqrd;
    }
    return correlations;
  }
  static autocorrelation2dNormalized(mat2d2) {
    let result = [];
    for (let y = 0; y < mat2d2.length; y++) {
      result.push([]);
      for (let x2 = 0; x2 < mat2d2[y].length; x2++) {
        let G = 0;
        let _G = 0;
        for (let b = 0; b < mat2d2.length; b++) {
          for (let a = 0; a < mat2d2[b].length; a++) {
            G += mat2d2[y][x2] * mat2d2[mat2d2.length - 1 - b][mat2d2[y].length - 1 - a];
            _G += mat2d2[y][x2] * mat2d2[mat2d2.length - 1][mat2d2[y].length - 1];
          }
        }
        result[y][x2] = G / _G - 1;
      }
    }
    return result;
  }
  static crosscorrelation2d(mat2d1, mat2d2) {
    let result = [];
    for (let y = 0; y < mat2d1.length; y++) {
      result.push([]);
      for (let x2 = 0; x2 < mat2d1[y].length; x2++) {
        let G = 0;
        for (let b = 0; b < mat2d2.length; b++) {
          for (let a = 0; a < mat2d2[b].length; a++) {
            G += mat2d1[y][x2] * mat2d2[mat2d2.length - 1 - b][mat2d2[y].length - 1 - a];
          }
        }
        result[y][x2] = G;
      }
    }
    return result;
  }
  static crosscorrelation2dNormalized(mat2d1, mat2d2) {
    let result = [];
    for (let y = 0; y < mat2d1.length; y++) {
      result.push([]);
      for (let x2 = 0; x2 < mat2d1[y].length; x2++) {
        let G = 0;
        let _G = 0;
        for (let b = 0; b < mat2d2.length; b++) {
          for (let a = 0; a < mat2d2[b].length; a++) {
            G += mat2d1[y][x2] * mat2d2[mat2d.length - 1 - b][mat2d2[y].length - 1 - a];
            _G += mat2d1[y][x2] * mat2d2[mat2d2.length - 1][mat2d2[y].length - 1];
          }
        }
        result[y][x2] = G / _G - 1;
      }
    }
    return result;
  }
  static correlograms(dat = [[], []]) {
    var correlograms = [];
    dat.forEach((row1, i) => {
      dat.forEach((row2, j) => {
        if (j >= i) {
          correlograms.push(_Math2.crosscorrelation(row1, row2));
        }
      });
    });
    return correlograms;
  }
  static dft(sineWave = []) {
    var TWOPI = 2 * 3.141592653589793;
    var real = [];
    var imag = [];
    var mags = [];
    for (var k = 0; k < sineWave.length; k++) {
      real.push(0);
      imag.push(0);
      for (var j = 0; j < sineWave.length; j++) {
        var shared = TWOPI * k * j / sineWave.length;
        real[k] = real[k] + sineWave[j] * Math.cos(shared);
        imag[k] = imag[k] - sineWave[j] * Math.sin(shared);
      }
      mags.push(Math.sqrt(real[k] * real[k] + imag[k] * imag[k]));
    }
    function orderMagnitudes(unorderedMags) {
      return [...unorderedMags.slice(Math.ceil(unorderedMags.length * 0.5), unorderedMags.length), ...unorderedMags.slice(0, Math.ceil(unorderedMags.length * 0.5))];
    }
    mags = orderMagnitudes(mags);
    let halflen = mags.length * 0.5;
    let freqs = mags.map((m, i) => {
      return i - halflen;
    });
    return {
      real,
      imag,
      freqs,
      mags
    };
  }
  static sma(arr = [], window) {
    var smaArr = [];
    for (var i = 0; i < arr.length; i++) {
      if (i == 0) {
        smaArr.push(arr[0]);
      } else if (i < window) {
        var arrslice = arr.slice(0, i + 1);
        smaArr.push(arrslice.reduce((previous, current) => current += previous) / (i + 1));
      } else {
        var arrslice = arr.slice(i - window, i);
        smaArr.push(arrslice.reduce((previous, current) => current += previous) / window);
      }
    }
    return smaArr;
  }
  static sum(arr = []) {
    if (arr.length > 0) {
      var sum = arr.reduce((prev, curr) => curr += prev);
      return sum;
    } else {
      return 0;
    }
  }
  static reduceArrByFactor(arr, factor = 2) {
    let x2 = arr.filter((element, index) => {
      return index % factor === 0;
    });
    return x2;
  }
  static makeArr(startValue, stopValue, nSteps) {
    var arr = [];
    var step = (stopValue - startValue) / (nSteps - 1);
    for (var i = 0; i < nSteps; i++) {
      arr.push(startValue + step * i);
    }
    return arr;
  }
  static autoscale(array, stackedLines = 1, stackPosition = 0, centerZero = false) {
    if (array?.length === 0)
      return array;
    let max = Math.max(...array);
    let min = Math.min(...array);
    let _lines = 1 / stackedLines;
    let scalar;
    if (centerZero) {
      let absmax = Math.max(Math.abs(min), Math.abs(max));
      scalar = _lines / absmax;
      return array.map((y) => y * scalar + (_lines * (stackPosition + 1) * 2 - 1 - _lines));
    } else {
      scalar = _lines / (max - min);
      return array.map((y) => 2 * ((y - min) * scalar - 1 / (2 * stackedLines)) + (_lines * (stackPosition + 1) * 2 - 1 - _lines));
    }
  }
  static absmax(array) {
    return Math.max(Math.abs(Math.min(...array)), Math.max(...array));
  }
  static downsample(array, fitCount, scalar = 1) {
    if (array.length > fitCount) {
      let output = new Array(fitCount);
      let incr = array.length / fitCount;
      let lastIdx = array.length - 1;
      let last = 0;
      let counter = 0;
      for (let i = incr; i < array.length; i += incr) {
        let rounded = Math.round(i);
        if (rounded > lastIdx)
          rounded = lastIdx;
        for (let j = last; j < rounded; j++) {
          output[counter] += array[j];
        }
        output[counter] /= (rounded - last) * scalar;
        counter++;
        last = rounded;
      }
      return output;
    } else
      return array;
  }
  static interpolateArray(data, fitCount, scalar = 1) {
    var linearInterpolate = function(before2, after2, atPoint2) {
      return (before2 + (after2 - before2) * atPoint2) * scalar;
    };
    var newData = new Array();
    var springFactor = (data.length - 1) / (fitCount - 1);
    newData[0] = data[0];
    for (var i = 1; i < fitCount - 1; i++) {
      var tmp = i * springFactor;
      var before = Math.floor(tmp);
      var after = Math.ceil(tmp);
      var atPoint = tmp - before;
      newData[i] = linearInterpolate(data[before], data[after], atPoint);
    }
    newData[fitCount - 1] = data[data.length - 1];
    return newData;
  }
  static isExtrema(arr, critical = "peak") {
    let ref = [...arr];
    if (ref.length % 2 === 0)
      ref.pop();
    if (arr.length > 1) {
      let pass = true;
      for (let i = 0; i < ref.length; i++) {
        let val = ref[i];
        if (critical === "peak") {
          if (i < Math.floor(ref.length * 0.5) && val >= ref[Math.floor(ref.length * 0.5)]) {
            pass = false;
            break;
          } else if (i > Math.floor(ref.length * 0.5) && val >= ref[Math.floor(ref.length * 0.5)]) {
            pass = false;
            break;
          }
        } else if (critical === "valley") {
          if (i < Math.floor(ref.length * 0.5) && val <= ref[Math.floor(ref.length * 0.5)]) {
            pass = false;
            break;
          } else if (i > Math.floor(ref.length * 0.5) && val <= ref[Math.floor(ref.length * 0.5)]) {
            pass = false;
            break;
          }
        } else {
          if (i < Math.floor(ref.length * 0.5) && val <= ref[Math.floor(ref.length * 0.5)]) {
            pass = false;
            break;
          } else if (i > Math.floor(ref.length * 0.5) && val <= ref[Math.floor(ref.length * 0.5)]) {
            pass = false;
            break;
          }
        }
      }
      if (critical !== "peak" && critical !== "valley" && pass === false) {
        pass = true;
        for (let i = 0; i < ref.length; i++) {
          let val = ref[i];
          if (i < Math.floor(ref.length * 0.5) && val >= ref[Math.floor(ref.length * 0.5)]) {
            pass = false;
            break;
          } else if (i > Math.floor(ref.length * 0.5) && val >= ref[Math.floor(ref.length * 0.5)]) {
            pass = false;
            break;
          }
        }
      }
      return pass;
    } else
      return void 0;
  }
  static isCriticalPoint(arr, critical = "peak") {
    let ref = [...arr];
    if (ref.length % 2 === 0)
      ref.pop();
    if (arr.length > 1) {
      let pass = true;
      for (let i = 0; i < ref.length; i++) {
        let val = ref[i];
        if (critical === "peak") {
          if (i < ref.length * 0.5 && val <= 0) {
            pass = false;
            break;
          } else if (i > ref.length * 0.5 && val > 0) {
            pass = false;
            break;
          }
        } else if (critical === "valley") {
          if (i < ref.length * 0.5 && val >= 0) {
            pass = false;
            break;
          } else if (i > ref.length * 0.5 && val < 0) {
            pass = false;
            break;
          }
        } else {
          if (i < ref.length * 0.5 && val >= 0) {
            pass = false;
            break;
          } else if (i > ref.length * 0.5 && val < 0) {
            pass = false;
            break;
          }
        }
      }
      if (critical !== "peak" && critical !== "valley" && pass === false) {
        pass = true;
        for (let i = 0; i < ref.length; i++) {
          let val = ref[i];
          if (i < ref.length * 0.5 && val <= 0) {
            pass = false;
            break;
          } else if (i > ref.length * 0.5 && val > 0) {
            pass = false;
            break;
          }
        }
      }
      return pass;
    } else
      return void 0;
  }
  static getPeakThreshold(arr, peakIndices, thresholdVar) {
    let threshold;
    let filtered = arr.filter((o, i) => {
      if (peakIndices.indexOf(i) > -1)
        return true;
    });
    if (thresholdVar === 0) {
      threshold = this.mean(filtered);
    } else
      threshold = (thresholdVar + this.mean(filtered)) * 0.5;
    return threshold;
  }
  static column(mat, x2) {
    let col = new Array(mat.length).fill(0).map(() => new Array(1).fill(0));
    for (let i = 0; i < mat.length; i++) {
      col[i][0] = mat[i][x2];
    }
    return col;
  }
  static flatten_vector(v) {
    let v_new = [];
    for (let i = 0; i < v.length; i++) {
      v_new[i] = v[i][0];
    }
    return v_new;
  }
  static squared_difference(v1, v2) {
    let sum = 0;
    for (let i = 0; i < v1.length; i++) {
      sum = sum + Math.pow(v1[i] - v2[i], 2);
    }
    return sum;
  }
  static shift_deflate(mat, eigenvalue, eigenvector) {
    let len = Math.sqrt(this.matmul(this.transpose(eigenvector), eigenvector));
    let U = this.matscale(eigenvector, 1 / len);
    let delta = this.matscale(this.matmul(U, this.transpose(U)), eigenvalue);
    let M_new = this.matsub(mat, delta);
    return M_new;
  }
  static eigenvalue_of_vector(mat, eigenvector) {
    ev = this.matmul(this.matmul(this.transpose(eigenvector), mat), eigenvector);
    return ev;
  }
  static power_iteration(mat, tolerance = 1e-5, max_iterations = 1e3) {
    let rank = mat.length;
    let eigenvector = new Array(rank).fill(0).map(() => new Array(1).fill(Math.sqrt(rank)));
    let eigenvalue = this.eigenvalue_of_vector(mat, eigenvector);
    let epsilon = 1;
    let iter = 0;
    while (epsilon > tolerance && iter < max_iterations) {
      let old_eigenvalue = JSON.parse(JSON.stringify(eigenvalue));
      let Mv = this.matmul(mat, eigenvector);
      eigenvector = this.normalize(Mv);
      eigenvalue = this.eigenvalue_of_vector(mat, eigenvector);
      epsilon = Math.abs(eigenvalue - old_eigenvalue);
      iter++;
    }
    ;
    return [eigenvalue, eigenvector];
  }
  static eigens(mat, tolerance = 1e-4, max_iterations = 1e3) {
    let eigenvalues = [];
    let eigenvectors = [];
    for (let i = 0; i < mat.length; i++) {
      let result = this.power_iteration(mat, tolerance, max_iterations);
      let eigenvalue = result[0];
      let eigenvector = result[1];
      eigenvalues[i] = eigenvalue;
      eigenvectors[i] = this.flatten_vector(eigenvector);
      mat = this.shift_deflate(mat, eigenvalue, eigenvector);
    }
    return [eigenvalues, eigenvectors];
  }
  static pca(mat, tolerance = 1e-5) {
    let dims = mat.length;
    let t = new Array(dims);
    let p = new Array(dims);
    let mat_t = this.transpose(mat);
    t[0] = this.column(mat, 0);
    let epsilon = 1;
    let iter = 0;
    while (espilon > tolerance) {
      iter++;
      p[0] = this.matmul(mat_t, t[0]);
      let tp = this.matmul(this.transpose(t[0]), t[0]);
      p[0] = this.matscale(p[0], 1 / tp);
      let p_length = Math.sqrt(this.matmul(this.transpose(p[0]), p[0]));
      p[0] = this.matscale(p[0], 1 / p_length);
      let t_new = this.matmul(mat, p[0]);
      let pp = this.matmul(this.transpose(p[0]), p[0]);
      t_new = this.matscale(t_new, 1 / pp);
      epsilon = this.squared_difference(t[0], t_new);
      t[0] = JSON.parse(JSON.stringify(t_new));
    }
    let components = this.matmul(this.transpose(t[0]), t[0]);
    return components;
  }
  static circularBuffer(arr, newEntries) {
    if (Array.isArray(newEntries)) {
      if (newEntries.length < arr.length) {
        let slice = arr.slice(newEntries.length);
        let len = arr.length;
        arr.splice(
          0,
          len,
          ...slice,
          ...newEntries
        );
      } else if (newEntries.length > arr.length) {
        let len = arr.length;
        arr.splice(
          0,
          len,
          newEntries.slice(len - newEntries.length)
        );
      } else {
        arr.splice(0, arr.length, ...newEntries);
      }
    } else {
      arr.push(newEntries);
      arr.shift();
    }
    return arr;
  }
  static HSLToRGB(h, s, l, scalar = 255) {
    s /= 100;
    l /= 100;
    let c = (1 - Math.abs(2 * l - 1)) * s, x2 = c * (1 - Math.abs(h / 60 % 2 - 1)), m = l - c / 2, r = 0, g = 0, b = 0;
    if (0 <= h && h < 60) {
      r = c;
      g = x2;
      b = 0;
    } else if (60 <= h && h < 120) {
      r = x2;
      g = c;
      b = 0;
    } else if (120 <= h && h < 180) {
      r = 0;
      g = c;
      b = x2;
    } else if (180 <= h && h < 240) {
      r = 0;
      g = x2;
      b = c;
    } else if (240 <= h && h < 300) {
      r = x2;
      g = 0;
      b = c;
    } else if (300 <= h && h < 360) {
      r = c;
      g = 0;
      b = x2;
    }
    r = (r + m) * scalar;
    g = (g + m) * scalar;
    b = (b + m) * scalar;
    return [r, g, b];
  }
  static p300(event_timestamps = [], raw_signal = [], signal_timestamps = [], sps = 256) {
    let smoothingstep = Math.floor(sps / 10);
    let smoothed = this.sma(raw_signal, smoothingstep);
    let peaks = this.peakDetect(smoothed, "peak", smoothingstep);
    let mean = this.mean(smoothed);
    let std = this.std(smoothed, mean);
    let p_idx = 0;
    let candidates = [];
    if (peaks.length > 0) {
      event_timestamps.forEach((t, j) => {
        while (signal_timestamps[peaks[p_idx]] < t + 200) {
          p_idx++;
          if (!peaks[p_idx])
            break;
        }
        let tempi = 0;
        let tempcandidates = [];
        while (signal_timestamps[peaks[p_idx + tempi]] < t + 600) {
          tempcandidates.push(p_idx + tempi);
          tempi++;
          if (!peaks[p_idx + tempi])
            break;
        }
        if (tempcandidates.length > 1) {
          let peakvals = [];
          tempcandidates.forEach((tc) => {
            peakvals.push(smoothed[peaks[tc]]);
          });
          let max = Math.max(...peakvals);
          let maxi = tempcandidates[peakvals.indexOf(max)];
          candidates.push({
            event_timestamp: t,
            event_index: j,
            peak_timestamp: signal_timestamps[[peaks[maxi]]],
            signal_index: [peaks[maxi]],
            signal_amplitude: raw_signal[[peaks[maxi]]],
            zscore: (smoothed[peaks[maxi]] - mean) / std
          });
        } else if (tempcandidates.length === 1)
          candidates.push({
            event_timestamp: t,
            event_index: j,
            peak_timestamp: signal_timestamps[peaks[tempcandidates[0]]],
            signal_index: peaks[tempcandidates[0]],
            signal_amplitude: raw_signal[[peaks[tempcandidates[0]]]],
            zscore: (smoothed[peaks[tempcandidates[0]]] - mean) / std
          });
      });
    }
    return candidates;
  }
};
var Math2 = _Math2;
__publicField(Math2, "TWO_PI", Math.PI * 2);
__publicField(Math2, "C", 299792458);
__publicField(Math2, "G", 66743e-15);
__publicField(Math2, "h", 662607015e-42);
__publicField(Math2, "R", 8314.32);
__publicField(Math2, "Ra", 287);
__publicField(Math2, "H", 69.3);
__publicField(Math2, "kbar", 1054571817e-43);
__publicField(Math2, "kB", 1380649e-29);
__publicField(Math2, "ke", 89875517923e-1);
__publicField(Math2, "me", 91093837015e-41);
__publicField(Math2, "mp", 167262192369e-38);
__publicField(Math2, "mn", 167492749804e-38);
__publicField(Math2, "P0", 101325);
__publicField(Math2, "T0", 288.15);
__publicField(Math2, "p0", 1.225);
__publicField(Math2, "Na", 60220978e16);
__publicField(Math2, "y", 1.405);
__publicField(Math2, "M0", 28.96643);
__publicField(Math2, "g0", 9.80665);
__publicField(Math2, "Re", 6378100);
__publicField(Math2, "B", 1458e-9);
__publicField(Math2, "S", 110.4);
__publicField(Math2, "Sigma", 365e-12);
__publicField(Math2, "imgkernels", {
  edgeDetection: [
    [-1, -1, -1],
    [-1, 8, -1],
    [-1, -1, -1]
  ],
  boxBlur: [
    [1 / 9, 1 / 9, 1 / 9],
    [1 / 9, 1 / 9, 1 / 9],
    [1 / 9, 1 / 9, 1 / 9]
  ],
  sobelLeft: [
    [1, 0, -1],
    [2, 0, -2],
    [1, 0, -1]
  ],
  sobelRight: [
    [-1, 0, 1],
    [-2, 0, 2],
    [-1, 0, 1]
  ],
  sobelTop: [
    [1, 2, 1],
    [0, 0, 0],
    [-1, -2, -1]
  ],
  sobelBottom: [
    [-1, 2, 1],
    [0, 0, 0],
    [1, 2, 1]
  ],
  identity: [
    [0, 0, 0],
    [0, 1, 0],
    [0, 0, 0]
  ],
  gaussian3x3: [
    [1, 2, 1],
    [2, 4, 2],
    [1, 2, 1]
  ],
  guassian7x7: [
    [0, 0, 0, 5, 0, 0, 0],
    [0, 5, 18, 32, 18, 5, 0],
    [0, 18, 64, 100, 64, 18, 0],
    [5, 32, 100, 100, 100, 32, 5],
    [0, 18, 64, 100, 64, 18, 0],
    [0, 5, 18, 32, 18, 5, 0],
    [0, 0, 0, 5, 0, 0, 0]
  ],
  emboss: [
    [-2, -1, 0],
    [-1, 1, 1],
    [0, 1, 2]
  ],
  sharpen: [
    [0, -1, 0],
    [-1, 5, -1],
    [0, -1, 0]
  ]
});
__publicField(Math2, "integral", (func = (x2) => {
  let y = x2;
  return y;
}, range = [], stepx = 0.01) => {
  let area = 0;
  for (let i = range[0]; i < range[1]; i += stepx) {
    let y = func(i);
    area += y * stepx;
  }
  return area;
});
__publicField(Math2, "dintegral", (func = (x2, y) => {
  let z = x2 + y;
  return z;
}, range = [[], []], stepx = 0.01, stepy = stepx) => {
  let volume = 0;
  for (let i = range[0][0] + stepx; i < range[0][1]; i += stepx) {
    for (let j = range[1][0] + stepy; j < range[1][1]; j += stepy) {
      let z = func(i, j);
      volume += z * stepx * stepy;
    }
  }
  return volume;
});
__publicField(Math2, "tintegral", (func = (x2, y, z) => {
  let w = x2 + y + z;
  return w;
}, range = [[], [], []], stepx = 0.01, stepy = stepx, stepz = stepx) => {
  let volume = 0;
  for (let i = range[0][0] + stepx; i < range[0][1]; i += stepx) {
    for (let j = range[1][0] + stepy; j < range[1][1]; j += stepy) {
      for (let k = range[2][0] + stepz; k < range[2][1]; k += stepz) {
        let w = func(i, j, k);
        volume += w * stepx * stepy * stepz;
      }
    }
  }
  return volume;
});
__publicField(Math2, "pintegral", (func = (x2) => {
  let y = x2;
  return y;
}, range = [], stepx = 0.01) => {
  let length = 0;
  let y0 = void 0;
  let yi = void 0;
  for (let i = range[0]; i < range[1]; i += stepx) {
    y0 = yi;
    yi = func(i);
    if (y0)
      length += _Math2.distance([0, y0], [stepx, yi]);
  }
  return length;
});
__publicField(Math2, "meshgrid", _Math2.generateCoordinateSpace);
__publicField(Math2, "autocorrelation2d", (mat2d2) => {
  let result = [];
  for (let y = 0; y < mat2d2.length; y++) {
    result.push([]);
    for (let x2 = 0; x2 < mat2d2[y].length; x2++) {
      let G = 0;
      for (let b = 0; b < mat2d2.length; b++) {
        for (let a = 0; a < mat2d2[b].length; a++) {
          G += mat2d2[y][x2] * mat2d2[mat2d2.length - 1 - b][mat2d2[y].length - 1 - a];
        }
      }
      result[y][x2] = G;
    }
  }
  return result;
});
__publicField(Math2, "lerp", _Math2.makeArr);
__publicField(Math2, "upsample", _Math2.interpolateArray);
__publicField(Math2, "lerp", (v0, v1, fit, floor = true) => {
  function lerp(v02, v12, t) {
    return (1 - t) * v02 + t * v12;
  }
  function interpolerp(v02, v12, fit2, floor2 = true) {
    if (fit2 <= 2)
      return [v02, v12];
    let a = 1 / fit2;
    let result = new Array(fit2);
    result[0] = v02;
    for (let i = 1; i <= fit2; i++) {
      result[i] = lerp(v02, v12, a * i);
      if (floor2)
        result[i] = Math.floor(result[i]);
    }
    return result;
  }
});
__publicField(Math2, "peakDetect", (smoothedArray, type = "peak", window = 49) => {
  let mid = Math.floor(window * 0.5);
  let peaks = [];
  for (let i = 0; i < smoothedArray.length - window; i++) {
    let isPeak = _Math2.isExtrema(smoothedArray.slice(i, i + window), type);
    if (isPeak) {
      peaks.push(i + mid - 1);
    }
  }
  return peaks;
});
Object.assign(Math, Math2);
export {
  Math2
};
