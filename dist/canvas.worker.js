(()=>{var mouseEventHandler=makeSendPropertiesHandler(["ctrlKey","metaKey","shiftKey","button","pointerType","clientX","clientY","pageX","pageY"]);var wheelEventHandlerImpl=makeSendPropertiesHandler(["deltaX","deltaY"]);var keydownEventHandler=makeSendPropertiesHandler(["ctrlKey","metaKey","shiftKey","keyCode"]);function wheelEventHandler(event,sendFn){event.preventDefault();wheelEventHandlerImpl(event,sendFn)}function preventDefaultHandler(event){event.preventDefault()}function copyProperties(src,properties,dst){for(const name of properties){dst[name]=src[name]}}function makeSendPropertiesHandler(properties){return function sendProperties(event,sendFn){const data={type:event.type};copyProperties(event,properties,data);sendFn(data)}}function touchEventHandler(event,sendFn){const touches=[];const data={type:event.type,touches};for(let i=0;i<event.touches.length;++i){const touch=event.touches[i];touches.push({pageX:touch.pageX,pageY:touch.pageY})}sendFn(data)}var orbitKeys={"37":true,"38":true,"39":true,"40":true};function filteredKeydownEventHandler(event,sendFn){const{keyCode}=event;if(orbitKeys[keyCode]){event.preventDefault();keydownEventHandler(event,sendFn)}}var eventHandlers={contextmenu:preventDefaultHandler,mousedown:mouseEventHandler,mousemove:mouseEventHandler,mouseup:mouseEventHandler,pointerdown:mouseEventHandler,pointermove:mouseEventHandler,pointerup:mouseEventHandler,touchstart:touchEventHandler,touchmove:touchEventHandler,touchend:touchEventHandler,wheel:wheelEventHandler,keydown:filteredKeydownEventHandler};function initProxyElement(element,worker,id){if(!id)id="proxy"+Math.floor(Math.random()*1e15);const sendEvent=data=>{worker.postMessage({route:"handleProxyEvent",args:[data,id]})};let entries=Object.entries(eventHandlers);for(const[eventName,handler]of entries){element.addEventListener(eventName,function(event){handler(event,sendEvent)})}const sendSize=()=>{const rect=element.getBoundingClientRect();sendEvent({type:"resize",left:rect.left,top:rect.top,width:element.clientWidth,height:element.clientHeight})};sendSize();globalThis.addEventListener("resize",sendSize);return id}var EventDispatcher=class{addEventListener(type,listener){if(this._listeners===void 0)this._listeners={};const listeners=this._listeners;if(listeners[type]===void 0){listeners[type]=[]}if(listeners[type].indexOf(listener)===-1){listeners[type].push(listener)}}hasEventListener(type,listener){if(this._listeners===void 0)return false;const listeners=this._listeners;return listeners[type]!==void 0&&listeners[type].indexOf(listener)!==-1}removeEventListener(type,listener){if(this._listeners===void 0)return;const listeners=this._listeners;const listenerArray=listeners[type];if(listenerArray!==void 0){const index=listenerArray.indexOf(listener);if(index!==-1){listenerArray.splice(index,1)}}}dispatchEvent(event,target){if(this._listeners===void 0)return;const listeners=this._listeners;const listenerArray=listeners[event.type];if(listenerArray!==void 0){if(!target)event.target=this;else event.target=target;const array=listenerArray.slice(0);for(let i=0,l=array.length;i<l;i++){array[i].call(this,event)}event.target=null}}};function noop(){}var ElementProxyReceiver=class extends EventDispatcher{constructor(){super();this._listeners={};this.style={};this.setPointerCapture=()=>{};this.releasePointerCapture=()=>{};this.getBoundingClientRect=()=>{return{left:this.left,top:this.top,width:this.width,height:this.height,right:this.left+this.width,bottom:this.top+this.height}};this.handleEvent=data=>{if(data.type==="resize"){this.left=data.left;this.top=data.top;this.width=data.width;this.height=data.height;if(typeof this.proxied==="object"){this.proxied.style.width=this.width;this.proxied.style.height=this.height;this.proxied.clientWidth=this.width;this.proxied.clientHeight=this.height}}data.preventDefault=noop;data.stopPropagation=noop;this.dispatchEvent(data,this.proxied)};this.style={}}get clientWidth(){return this.width}get clientHeight(){return this.height}focus(){}};var ProxyManager=class{constructor(){this.targets={};this.makeProxy=(id,addTo=void 0)=>{if(!id)id=`proxyReceiver${Math.floor(Math.random()*1e15)}`;let proxy;if(this.targets[id])proxy=this.targets[id];else{proxy=new ElementProxyReceiver;this.targets[id]=proxy}if(typeof addTo==="object"){addTo.proxy=proxy;proxy.proxied=addTo;if(typeof WorkerGlobalScope!=="undefined")addTo.style=proxy.style;if(proxy.width){addTo.style.width=proxy.width;addTo.clientWidth=proxy.width}if(proxy.height){addTo.style.height=proxy.height;addTo.clientHeight=proxy.height}addTo.setPointerCapture=proxy.setPointerCapture.bind(proxy);addTo.releasePointerCapture=proxy.releasePointerCapture.bind(proxy);addTo.getBoundingClientRect=proxy.getBoundingClientRect.bind(proxy);addTo.addEventListener=proxy.addEventListener.bind(proxy);addTo.removeEventListener=proxy.removeEventListener.bind(proxy);addTo.handleEvent=proxy.handleEvent.bind(proxy);addTo.dispatchEvent=proxy.dispatchEvent.bind(proxy);addTo.focus=proxy.focus.bind(proxy)}};this.getProxy=id=>{return this.targets[id]};this.handleEvent=(data,id)=>{if(!this.targets[id])this.makeProxy(id);if(this.targets[id]){this.targets[id].handleEvent(data);return true}return void 0};if(!globalThis.document)globalThis.document={}}};function makeProxy(id,elm){if(this.graph){if(!this.graph.ProxyManager)this.graph.ProxyManager=new ProxyManager;this.graph.ProxyManager.makeProxy(id,elm)}else{if(!globalThis.ProxyManager)globalThis.ProxyManager=new ProxyManager;globalThis.ProxyManager.makeProxy(id,elm)}return id}function handleProxyEvent(data,id){if(this.graph){if(!this.graph.ProxyManager)this.graph.ProxyManager=new ProxyManager;if(this.graph.ProxyManager.handleEvent(data,id))return data}else{if(!globalThis.ProxyManager)globalThis.ProxyManager=new ProxyManager;if(globalThis.ProxyManager.handleEvent(data,id))return data}}var proxyElementWorkerRoutes={initProxyElement,makeProxy,handleProxyEvent};function Renderer(options){if(options.worker){let worker=options.worker;let route=options.route;if(worker instanceof Blob||typeof worker==="string"){worker=new Worker(worker)}delete options.worker;delete options.route;return transferCanvas(worker,options,route)}else return setupCanvas(options)}function transferCanvas(worker,options,route){if(!options)return void 0;if(!options._id)options._id=`canvas${Math.floor(Math.random()*1e15)}`;let offscreen=options.canvas.transferControlToOffscreen();if(!options.width)options.width=options.canvas.width;if(!options.height)options.height=options.canvas.height;let message={route:route?route:"setupCanvas",args:{...options,canvas:offscreen}};if(this.graph)this.graph.run("initProxyElement",options.canvas,worker,options._id);else initProxyElement(options.canvas,worker,options._id);if(options.draw){if(typeof options.draw==="function")message.args.draw=options.draw.toString();else message.args.draw=options.draw}if(options.update){if(typeof options.update==="function")message.args.update=options.update.toString();else message.args.update=options.update}if(options.init){if(typeof options.init==="function")message.args.init=options.init.toString();else message.args.init=options.init}if(options.clear){if(typeof options.clear==="function")message.args.clear=options.clear.toString();else message.args.clear=options.clear}let transfer=[offscreen];if(options.transfer){transfer.push(...options.transfer);delete options.transfer}worker.postMessage(message,transfer);const canvascontrols={_id:options._id,width:options.width,height:options.height,worker,draw:props=>{worker.postMessage({route:"drawFrame",args:[props,options._id]})},update:props=>{worker.postMessage({route:"updateCanvas",args:[props,options._id]})},clear:()=>{worker.postMessage({route:"clearCanvas",args:options._id})},init:()=>{worker.postMessage({route:"initCanvas",args:options._id})},stop:()=>{worker.postMessage({route:"stopAnim",args:options._id})},start:()=>{worker.postMessage({route:"startAnim",args:options._id})},set:newDrawProps=>{worker.postMessage({route:"setDraw",args:[newDrawProps,options._id]})},terminate:()=>{worker.terminate()}};return canvascontrols}function setDraw(settings,_id){let canvasopts;if(this.graph){if(_id)canvasopts=this.graph.CANVASES?.[settings._id];else if(settings._id)canvasopts=this.graph.CANVASES?.[settings._id];else canvasopts=this.graph.CANVASES?.[Object.keys(this.graph.CANVASES)[0]]}else{if(_id)canvasopts=globalThis.CANVASES?.[settings._id];else if(settings._id)canvasopts=globalThis.CANVASES?.[settings._id];else canvasopts=globalThis.CANVASES?.[Object.keys(globalThis.CANVASES)[0]]}if(canvasopts){if(settings.canvas){canvasopts.canvas=settings.canvas;if(this.graph)this.graph.run("makeProxy",canvasopts._id,canvasopts.canvas);else proxyElementWorkerRoutes.makeProxy(canvasopts._id,canvasopts.canvas)}if(typeof settings.context==="string")canvasopts.context=canvasopts.canvas.getContext(settings.context);else if(settings.context)canvasopts.context=settings.context;if(settings.width)canvasopts.canvas.width=settings.width;if(settings.height)canvasopts.canvas.height=settings.height;if(typeof settings.draw==="string")settings.draw=parseFunctionFromText(settings.draw);if(typeof settings.draw==="function"){canvasopts.draw=settings.draw}if(typeof settings.update==="string")settings.update=parseFunctionFromText(settings.update);if(typeof settings.update==="function"){canvasopts.update=settings.update}if(typeof settings.init==="string")settings.init=parseFunctionFromText(settings.init);if(typeof settings.init==="function"){canvasopts.init=settings.init}if(typeof settings.clear==="string")settings.clear=parseFunctionFromText(settings.clear);if(typeof settings.clear==="function"){canvasopts.clear=settings.clear}return settings._id}return void 0}function setupCanvas(options){if(this.graph){if(!this.graph.CANVASES)this.graph.CANVASES={}}else if(!globalThis.CANVASES)globalThis.CANVASES={};let canvasOptions=options;options._id?canvasOptions._id=options._id:canvasOptions._id=`canvas${Math.floor(Math.random()*1e15)}`;typeof options.context==="string"?canvasOptions.context=options.canvas.getContext(options.context):canvasOptions.context=options.context;"animating"in options?canvasOptions.animating=options.animating:canvasOptions.animating=true;if(this.graph?.CANVASES[canvasOptions._id]){this.graph.run("setDraw",canvasOptions)}else if(globalThis.CANVASES[canvasOptions._id]){setDraw(canvasOptions)}else{canvasOptions.graph=this.graph;if(this.graph)this.graph.CANVASES[canvasOptions._id]=canvasOptions;else globalThis.CANVASES[canvasOptions._id]=canvasOptions;if(this.graph)this.graph.run("makeProxy",canvasOptions._id,canvasOptions.canvas);else proxyElementWorkerRoutes.makeProxy(canvasOptions._id,canvasOptions.canvas);if(options.width)canvasOptions.canvas.width=options.width;if(options.height)canvasOptions.canvas.height=options.height;if(typeof canvasOptions.draw==="string"){canvasOptions.draw=parseFunctionFromText(canvasOptions.draw)}else if(typeof canvasOptions.draw==="function"){canvasOptions.draw=canvasOptions.draw}if(typeof canvasOptions.update==="string"){canvasOptions.update=parseFunctionFromText(canvasOptions.update)}else if(typeof canvasOptions.update==="function"){canvasOptions.update=canvasOptions.update}if(typeof canvasOptions.init==="string"){canvasOptions.init=parseFunctionFromText(canvasOptions.init)}else if(typeof canvasOptions.init==="function"){canvasOptions.init=canvasOptions.init}if(typeof canvasOptions.clear==="string"){canvasOptions.clear=parseFunctionFromText(canvasOptions.clear)}else if(typeof canvasOptions.clear==="function"){canvasOptions.clear=canvasOptions.clear}if(typeof canvasOptions.init==="function")canvasOptions.init(canvasOptions,canvasOptions.canvas,canvasOptions.context);canvasOptions.stop=()=>{stopAnim(canvasOptions._id)};canvasOptions.start=draw=>{startAnim(canvasOptions._id,draw)};canvasOptions.set=settings=>{setDraw(settings,canvasOptions._id)};if(typeof canvasOptions.draw==="function"&&canvasOptions.animating){let draw=(s,canvas,context)=>{if(s.animating){s.draw(s,canvas,context);requestAnimationFrame(()=>{draw(s,canvas,context)})}};draw(canvasOptions,canvasOptions.canvas,canvasOptions.context)}}if(typeof WorkerGlobalScope!=="undefined"&&self instanceof WorkerGlobalScope)return canvasOptions._id;else{const canvascontrols={_id:options._id,width:options.width,height:options.height,draw:props=>{drawFrame(props,options._id)},update:props=>{updateCanvas(props,options._id)},clear:()=>{clearCanvas(options._id)},init:()=>{initCanvas(options._id)},stop:()=>{stopAnim(options._id)},start:()=>{startAnim(options._id)},set:newDrawProps=>{setDraw(newDrawProps,options._id)},terminate:()=>{stopAnim(options._id)}};return canvascontrols}}function drawFrame(props,_id){let canvasopts;if(this.graph){if(!_id)canvasopts=this.graph.CANVASES?.[Object.keys(this.graph.CANVASES)[0]];else canvasopts=this.graph.CANVASES?.[_id]}else{if(!_id)canvasopts=globalThis.CANVASES?.[Object.keys(globalThis.CANVASES)[0]];else canvasopts=globalThis.CANVASES?.[_id]}if(canvasopts){if(props)Object.assign(canvasopts,props);if(canvasopts.draw){canvasopts.draw(canvasopts,canvasopts.canvas,canvasopts.context);return _id}}return void 0}function clearCanvas(_id){let canvasopts;if(this.graph){if(!_id)canvasopts=this.graph.CANVASES?.[Object.keys(this.graph.CANVASES)[0]];else canvasopts=this.graph.CANVASES?.[_id]}else{if(!_id)canvasopts=globalThis.CANVASES?.[Object.keys(globalThis.CANVASES)[0]];else canvasopts=globalThis.CANVASES?.[_id]}if(canvasopts?.clear){canvasopts.clear(canvasopts,canvasopts.canvas,canvasopts.context);return _id}return void 0}function initCanvas(_id){let canvasopts;if(this.graph){if(!_id)canvasopts=this.graph.CANVASES?.[Object.keys(this.graph.CANVASES)[0]];else canvasopts=this.graph.CANVASES?.[_id]}else{if(!_id)canvasopts=globalThis.CANVASES?.[Object.keys(globalThis.CANVASES)[0]];else canvasopts=globalThis.CANVASES?.[_id]}if(canvasopts?.init){canvasopts.init(canvasopts,canvasopts.canvas,canvasopts.context);return _id}return void 0}function updateCanvas(input,_id){let canvasopts;if(this.graph){if(!_id)canvasopts=this.graph.CANVASES?.[Object.keys(this.graph.CANVASES)[0]];else canvasopts=this.graph.CANVASES?.[_id]}else{if(!_id)canvasopts=globalThis.CANVASES?.[Object.keys(globalThis.CANVASES)[0]];else canvasopts=globalThis.CANVASES?.[_id]}if(canvasopts?.update){canvasopts.update(canvasopts,canvasopts.canvas,canvasopts.context,input);return _id}return void 0}function setProps(props,_id){let canvasopts;if(this.graph){if(!_id)canvasopts=this.graph.CANVASES?.[Object.keys(this.graph.CANVASES)[0]];else canvasopts=this.graph.CANVASES?.[_id]}else{if(!_id)canvasopts=globalThis.CANVASES?.[Object.keys(globalThis.CANVASES)[0]];else canvasopts=globalThis.CANVASES?.[_id]}if(canvasopts){Object.assign(canvasopts,props);if(props.width)canvasopts.canvas.width=props.width;if(props.height)canvasopts.canvas.height=props.height;return _id}return void 0}function startAnim(_id,draw){let canvasopts;if(this.graph){if(!_id)canvasopts=this.graph.CANVASES?.[Object.keys(this.graph.CANVASES)[0]];else canvasopts=this.graph.CANVASES?.[_id]}else{if(!_id)canvasopts=globalThis.CANVASES?.[Object.keys(globalThis.CANVASES)[0]];else canvasopts=globalThis.CANVASES?.[_id]}canvasopts.animating=true;if(canvasopts&&draw){if(typeof draw==="string")draw=parseFunctionFromText(draw);if(typeof draw==="function"){canvasopts.draw=draw}return _id}if(typeof canvasopts?.draw==="function"){let draw2=(s,canvas,context)=>{if(s.animating){s.draw(s,canvas,context);requestAnimationFrame(()=>{draw2(s,canvas,context)})}};if(typeof canvasopts.clear==="function")canvasopts.clear(canvasopts,canvasopts.canvas,canvasopts.context);if(typeof canvasopts.init==="function")canvasopts.init(canvasopts,canvasopts.canvas,canvasopts.context);draw2(canvasopts,canvasopts.canvas,canvasopts.context);return _id}return void 0}function stopAnim(_id){let canvasopts;if(this.graph){if(!_id)canvasopts=this.graph.CANVASES?.[Object.keys(this.graph.CANVASES)[0]];else canvasopts=this.graph.CANVASES?.[_id]}else{if(!_id)canvasopts=globalThis.CANVASES?.[Object.keys(globalThis.CANVASES)[0]];else canvasopts=globalThis.CANVASES?.[_id]}if(canvasopts){canvasopts.animating=false;if(typeof canvasopts.clear==="function")canvasopts.clear(canvasopts,canvasopts.canvas,canvasopts.context);return _id}return void 0}var workerCanvasRoutes={...proxyElementWorkerRoutes,Renderer,transferCanvas,setupCanvas,setDraw,drawFrame,clearCanvas,initCanvas,updateCanvas,setProps,startAnim,stopAnim};function parseFunctionFromText(method=""){let getFunctionBody=methodString=>{return methodString.replace(/^\W*(function[^{]+\{([\s\S]*)\}|[^=]+=>[^{]*\{([\s\S]*)\}|[^=]+=>(.+))/i,"$2$3$4")};let getFunctionHead=methodString=>{let startindex=methodString.indexOf("=>")+1;if(startindex<=0){startindex=methodString.indexOf("){")}if(startindex<=0){startindex=methodString.indexOf(") {")}return methodString.slice(0,methodString.indexOf("{",startindex)+1)};let newFuncHead=getFunctionHead(method);let newFuncBody=getFunctionBody(method);let newFunc;if(newFuncHead.includes("function")){let varName=newFuncHead.split("(")[1].split(")")[0];newFunc=new Function(varName,newFuncBody)}else{if(newFuncHead.substring(0,6)===newFuncBody.substring(0,6)){let varName=newFuncHead.split("(")[1].split(")")[0];newFunc=new Function(varName,newFuncBody.substring(newFuncBody.indexOf("{")+1,newFuncBody.length-1))}else{try{newFunc=(0,eval)(newFuncHead+newFuncBody+"}")}catch{}}}return newFunc}var ColorRGBA=class{constructor(r,g,b,a){this.r=r;this.g=g;this.b=b;this.a=a}};var WebglBase=class{constructor(){this.scaleX=1;this.scaleY=1;this.offsetX=0;this.offsetY=0;this.loop=false;this._vbuffer=0;this._coord=0;this.visible=true;this.intensity=1;this.xy=new Float32Array([]);this.numPoints=0;this.color=new ColorRGBA(0,0,0,1);this.webglNumPoints=0}};var WebglLine=class extends WebglBase{constructor(c,numPoints){super();this.currentIndex=0;this.webglNumPoints=numPoints;this.numPoints=numPoints;this.color=c;this.xy=new Float32Array(2*this.webglNumPoints)}setX(index,x){this.xy[index*2]=x}setY(index,y){this.xy[index*2+1]=y}getX(index){return this.xy[index*2]}getY(index){return this.xy[index*2+1]}lineSpaceX(start,stepSize){for(let i=0;i<this.numPoints;i++){this.setX(i,start+stepSize*i)}}arrangeX(){this.lineSpaceX(-1,2/this.numPoints)}constY(c){for(let i=0;i<this.numPoints;i++){this.setY(i,c)}}shiftAdd(data){const shiftSize=data.length;for(let i=0;i<this.numPoints-shiftSize;i++){this.setY(i,this.getY(i+shiftSize))}for(let i=0;i<shiftSize;i++){this.setY(i+this.numPoints-shiftSize,data[i])}}addArrayY(yArray){if(this.currentIndex+yArray.length<=this.numPoints){for(let i=0;i<yArray.length;i++){this.setY(this.currentIndex,yArray[i]);this.currentIndex++}}}replaceArrayY(yArray){if(yArray.length==this.numPoints){for(let i=0;i<this.numPoints;i++){this.setY(i,yArray[i])}}}};var scaleAndAdd=(a,b,scale)=>{const out={x:0,y:0};out.x=a.x+b.x*scale;out.y=a.y+b.y*scale;return out};var normal=dir=>{const out=set(-dir.y,dir.x);return out};var direction=(a,b)=>{let out=subtract(a,b);out=normalize(out);return out};var add=(a,b)=>{const out={x:0,y:0};out.x=a.x+b.x;out.y=a.y+b.y;return out};var dot=(a,b)=>{return a.x*b.x+a.y*b.y};var normalize=a=>{const out={x:0,y:0};let len=a.x*a.x+a.y*a.y;if(len>0){len=1/Math.sqrt(len);out.x=a.x*len;out.y=a.y*len}return out};var set=(x,y)=>{const out={x:0,y:0};out.x=x;out.y=y;return out};var subtract=(a,b)=>{const out={x:0,y:0};out.x=a.x-b.x;out.y=a.y-b.y;return out};var PolyLine=lineXY=>{let curNormal;let lineA={x:0,y:0};let lineB={x:0,y:0};const out=[];const addNext=(normal2,length)=>{out.push({vec2:normal2,miterLength:length})};const getXY=index=>{return{x:lineXY[index*2],y:lineXY[index*2+1]}};lineA=direction(getXY(1),getXY(0));curNormal=normal(lineA);addNext(curNormal,1);const numPoints=lineXY.length/2;for(let i=1;i<numPoints-1;i++){const last=getXY(i-1);const cur=getXY(i);const next=getXY(i+1);lineA=direction(cur,last);curNormal=normal(lineA);lineB=direction(next,cur);const miter=computeMiter(lineA,lineB);const miterLen=computeMiterLen(lineA,miter,1);addNext(miter,miterLen)}lineA=direction(getXY(numPoints-1),getXY(numPoints-2));curNormal=normal(lineA);addNext(curNormal,1);return out};var computeMiter=(lineA,lineB)=>{let tangent=add(lineA,lineB);tangent=normalize(tangent);const miter=set(-tangent.y,tangent.x);return miter};var computeMiterLen=(lineA,miter,halfThick)=>{const tmp=set(-lineA.y,lineA.x);return halfThick/dot(miter,tmp)};var WebglThickLine=class extends WebglBase{constructor(c,numPoints,thickness){super();this.currentIndex=0;this._thicknessRequested=0;this._actualThickness=0;this.webglNumPoints=numPoints*2;this.numPoints=numPoints;this.color=c;this._thicknessRequested=thickness;this._linePoints=new Float32Array(numPoints*2);this.xy=new Float32Array(2*this.webglNumPoints)}convertToTriPoints(){const halfThick=this._actualThickness/2;const normals=PolyLine(this._linePoints);for(let i=0;i<this.numPoints;i++){const x=this._linePoints[2*i];const y=this._linePoints[2*i+1];const point={x,y};const top=scaleAndAdd(point,normals[i].vec2,normals[i].miterLength*halfThick);const bot=scaleAndAdd(point,normals[i].vec2,-normals[i].miterLength*halfThick);this.xy[i*4]=top.x;this.xy[i*4+1]=top.y;this.xy[i*4+2]=bot.x;this.xy[i*4+3]=bot.y}}setX(index,x){this._linePoints[index*2]=x}setY(index,y){this._linePoints[index*2+1]=y}lineSpaceX(start,stepSize){for(let i=0;i<this.numPoints;i++){this.setX(i,start+stepSize*i)}}setThickness(thickness){this._thicknessRequested=thickness}getThickness(){return this._thicknessRequested}setActualThickness(thickness){this._actualThickness=thickness}};var WebglPlot=class{constructor(canvas,options){this.debug=false;this.addLine=this.addDataLine;if(options==void 0){this.webgl=canvas.getContext("webgl",{antialias:true,transparent:false})}else{this.webgl=canvas.getContext("webgl",{antialias:options.antialias,transparent:options.transparent,desynchronized:options.deSync,powerPerformance:options.powerPerformance,preserveDrawing:options.preserveDrawing});this.debug=options.debug==void 0?false:options.debug}this.log("canvas type is: "+canvas.constructor.name);this.log(`[webgl-plot]:width=${canvas.width}, height=${canvas.height}`);this._linesData=[];this._linesAux=[];this._thickLines=[];this._surfaces=[];this.gScaleX=1;this.gScaleY=1;this.gXYratio=1;this.gOffsetX=0;this.gOffsetY=0;this.gLog10X=false;this.gLog10Y=false;this.webgl.clear(this.webgl.COLOR_BUFFER_BIT);this.webgl.viewport(0,0,canvas.width,canvas.height);this._progLine=this.webgl.createProgram();this.initThinLineProgram();this.webgl.enable(this.webgl.BLEND);this.webgl.blendFunc(this.webgl.SRC_ALPHA,this.webgl.ONE_MINUS_SRC_ALPHA)}get linesData(){return this._linesData}get linesAux(){return this._linesAux}get thickLines(){return this._thickLines}get surfaces(){return this._surfaces}_drawLines(lines){const webgl=this.webgl;lines.forEach(line=>{if(line.visible){webgl.useProgram(this._progLine);const uscale=webgl.getUniformLocation(this._progLine,"uscale");webgl.uniformMatrix2fv(uscale,false,new Float32Array([line.scaleX*this.gScaleX*(this.gLog10X?1/Math.log(10):1),0,0,line.scaleY*this.gScaleY*this.gXYratio*(this.gLog10Y?1/Math.log(10):1)]));const uoffset=webgl.getUniformLocation(this._progLine,"uoffset");webgl.uniform2fv(uoffset,new Float32Array([line.offsetX+this.gOffsetX,line.offsetY+this.gOffsetY]));const isLog=webgl.getUniformLocation(this._progLine,"is_log");webgl.uniform2iv(isLog,new Int32Array([this.gLog10X?1:0,this.gLog10Y?1:0]));const uColor=webgl.getUniformLocation(this._progLine,"uColor");webgl.uniform4fv(uColor,[line.color.r,line.color.g,line.color.b,line.color.a]);webgl.bufferData(webgl.ARRAY_BUFFER,line.xy,webgl.STREAM_DRAW);webgl.drawArrays(line.loop?webgl.LINE_LOOP:webgl.LINE_STRIP,0,line.webglNumPoints)}})}_drawSurfaces(squares){const webgl=this.webgl;squares.forEach(square=>{if(square.visible){webgl.useProgram(this._progLine);const uscale=webgl.getUniformLocation(this._progLine,"uscale");webgl.uniformMatrix2fv(uscale,false,new Float32Array([square.scaleX*this.gScaleX*(this.gLog10X?1/Math.log(10):1),0,0,square.scaleY*this.gScaleY*this.gXYratio*(this.gLog10Y?1/Math.log(10):1)]));const uoffset=webgl.getUniformLocation(this._progLine,"uoffset");webgl.uniform2fv(uoffset,new Float32Array([square.offsetX+this.gOffsetX,square.offsetY+this.gOffsetY]));const isLog=webgl.getUniformLocation(this._progLine,"is_log");webgl.uniform2iv(isLog,new Int32Array([this.gLog10X?1:0,this.gLog10Y?1:0]));const uColor=webgl.getUniformLocation(this._progLine,"uColor");webgl.uniform4fv(uColor,[square.color.r,square.color.g,square.color.b,square.color.a]);webgl.bufferData(webgl.ARRAY_BUFFER,square.xy,webgl.STREAM_DRAW);webgl.drawArrays(webgl.TRIANGLE_STRIP,0,square.webglNumPoints)}})}_drawTriangles(thickLine){const webgl=this.webgl;webgl.bufferData(webgl.ARRAY_BUFFER,thickLine.xy,webgl.STREAM_DRAW);webgl.useProgram(this._progLine);const uscale=webgl.getUniformLocation(this._progLine,"uscale");webgl.uniformMatrix2fv(uscale,false,new Float32Array([thickLine.scaleX*this.gScaleX*(this.gLog10X?1/Math.log(10):1),0,0,thickLine.scaleY*this.gScaleY*this.gXYratio*(this.gLog10Y?1/Math.log(10):1)]));const uoffset=webgl.getUniformLocation(this._progLine,"uoffset");webgl.uniform2fv(uoffset,new Float32Array([thickLine.offsetX+this.gOffsetX,thickLine.offsetY+this.gOffsetY]));const isLog=webgl.getUniformLocation(this._progLine,"is_log");webgl.uniform2iv(isLog,new Int32Array([0,0]));const uColor=webgl.getUniformLocation(this._progLine,"uColor");webgl.uniform4fv(uColor,[thickLine.color.r,thickLine.color.g,thickLine.color.b,thickLine.color.a]);webgl.drawArrays(webgl.TRIANGLE_STRIP,0,thickLine.xy.length/2)}_drawThickLines(){this._thickLines.forEach(thickLine=>{if(thickLine.visible){const calibFactor=Math.min(this.gScaleX,this.gScaleY);thickLine.setActualThickness(thickLine.getThickness()/calibFactor);thickLine.convertToTriPoints();this._drawTriangles(thickLine)}})}update(){this.clear();this.draw()}draw(){this._drawLines(this.linesData);this._drawLines(this.linesAux);this._drawThickLines();this._drawSurfaces(this.surfaces)}clear(){this.webgl.clear(this.webgl.COLOR_BUFFER_BIT)}_addLine(line){line._vbuffer=this.webgl.createBuffer();this.webgl.bindBuffer(this.webgl.ARRAY_BUFFER,line._vbuffer);this.webgl.bufferData(this.webgl.ARRAY_BUFFER,line.xy,this.webgl.STREAM_DRAW);line._coord=this.webgl.getAttribLocation(this._progLine,"coordinates");this.webgl.vertexAttribPointer(line._coord,2,this.webgl.FLOAT,false,0,0);this.webgl.enableVertexAttribArray(line._coord)}addDataLine(line){this._addLine(line);this.linesData.push(line)}addAuxLine(line){this._addLine(line);this.linesAux.push(line)}addThickLine(thickLine){this._addLine(thickLine);this._thickLines.push(thickLine)}addSurface(surface){this._addLine(surface);this.surfaces.push(surface)}initThinLineProgram(){const vertCode=`
      attribute vec2 coordinates;
      uniform mat2 uscale;
      uniform vec2 uoffset;
      uniform ivec2 is_log;

      void main(void) {
         float x = (is_log[0]==1) ? log(coordinates.x) : coordinates.x;
         float y = (is_log[1]==1) ? log(coordinates.y) : coordinates.y;
         vec2 line = vec2(x, y);
         gl_Position = vec4(uscale*line + uoffset, 0.0, 1.0);
      }`;const vertShader=this.webgl.createShader(this.webgl.VERTEX_SHADER);this.webgl.shaderSource(vertShader,vertCode);this.webgl.compileShader(vertShader);const fragCode=`
         precision mediump float;
         uniform highp vec4 uColor;
         void main(void) {
            gl_FragColor =  uColor;
         }`;const fragShader=this.webgl.createShader(this.webgl.FRAGMENT_SHADER);this.webgl.shaderSource(fragShader,fragCode);this.webgl.compileShader(fragShader);this._progLine=this.webgl.createProgram();this.webgl.attachShader(this._progLine,vertShader);this.webgl.attachShader(this._progLine,fragShader);this.webgl.linkProgram(this._progLine)}popDataLine(){this.linesData.pop()}removeAllLines(){this._linesData=[];this._linesAux=[];this._thickLines=[];this._surfaces=[]}removeDataLines(){this._linesData=[]}removeAuxLines(){this._linesAux=[]}viewport(a,b,c,d){this.webgl.viewport(a,b,c,d)}log(str){if(this.debug){console.log("[webgl-plot]:"+str)}}};var WebglLinePlotUtil=class{constructor(){this.plots={}}initPlot(settings,plot){if(!plot)plot=new WebglPlot(settings.canvas,settings.webglOptions);if(!settings._id){settings._id=`plot${Math.floor(Math.random()*1e15)}`}else if(this.plots[settings._id]){let oldsettings=this.plots[settings._id].initial;if(settings.lines)for(const key in settings.lines){if(oldsettings.lines[key]&&Array.isArray(settings.lines[key])){let newdata=settings.lines[key];settings.lines[key]=oldsettings.lines[key]}}settings=Object.assign(oldsettings,settings)}if(settings.overlay){if(typeof settings.overlay!=="object"){settings.overlay=document.createElement("canvas");settings.overlay.style.position="absolute";settings.overlay.width=settings.canvas.width;settings.overlay.height=settings.canvas.height;settings.canvas.appendChild(settings.overlay)}if(!settings.overlayCtx)settings.overlayCtx=settings.overlay.getContext("2d")}if(settings.width){settings.canvas.width=settings.width;if(settings.canvas.style)settings.canvas.style.width=settings.width+"px";if(typeof settings.overlay==="object"){settings.overlay.width=settings.width;if(settings.overlay.style)settings.overlay.style.width=settings.width+"px"}}if(settings.height){settings.canvas.height=settings.height;if(settings.canvas.style)settings.canvas.style.height=settings.height+"px";if(typeof settings.overlay==="object"){settings.overlay.height=settings.height;if(settings.overlay.style)settings.overlay.style.height=settings.height+"px"}}if(settings.lines?.timestamp)delete settings.lines.timestamp;let initialLns={};for(const key in settings.lines){initialLns[key]=Object.assign({},initialLns[key]);if(!("viewing"in settings.lines[key])){settings.lines[key].viewing=true}initialLns[key].viewing=settings.lines[key].viewing;initialLns[key].sps=settings.lines[key].sps;initialLns[key].nSec=settings.lines[key].nSec;initialLns[key].nPoints=settings.lines[key].nPoints;initialLns[key].ymin=settings.lines[key].ymin;initialLns[key].ymax=settings.lines[key].ymax;initialLns[key].units=settings.lines[key].units}let info={plot,settings,initial:Object.assign(Object.assign({},settings),{lines:initialLns}),anim:()=>{plot.update()}};this.plots[settings._id]=info;let i=0;let nLines=0;Object.keys(settings.lines).forEach(k=>{if(settings.lines[k]?.viewing!==false){nLines++}});settings.nLines=nLines;let canvas;let ctx;if(typeof settings.overlay==="object"){canvas=settings.overlay;ctx=settings.overlayCtx;ctx.clearRect(0,0,settings.overlay.width,settings.overlay.height);ctx.font=settings.overlayFont?settings.overlayFont:"1em Courier";ctx.fillStyle=settings.overlayColor?settings.overlayColor:"white"}for(const line in settings.lines){let s=settings.lines[line];if(Array.isArray(s)){s={values:s};settings.lines[line]=s}if(!("viewing"in s))s.viewing=true;if(s.color){if(Array.isArray(s.color)){s.color=new ColorRGBA(...s.color)}}else{let rgb=WebglLinePlotUtil.HSLToRGB(360*(i/nLines)%360,100,50,1);info.initial.lines[line].color=[...rgb,1];s.color=new ColorRGBA(...rgb,1)}let points;if(s.nSec&&s.sps){points=Math.ceil(s.nSec*s.sps)}else if(s.nPoints){points=s.nPoints}else if(s.values)points=s.values.length;else if(!points)points=1e3;if(!points)return;s.points=points;if(settings.lines[line].viewing===false){continue}if(s.width){s.line=new WebglThickLine(s.color,points,s.width);s.line.lineSpaceX(-1,2/s.line.numPoints)}else{s.line=new WebglLine(s.color,points);s.line.arrangeX()}if(s.values?.length===s.points){if(s.values.length!==points){if(s.interpolate){if(s.values.length>points){s.values=WebglLinePlotUtil.downsample(s.values,points)}else if(s.values.length<points){s.values=WebglLinePlotUtil.upsample(s.values,points)}}else{if(s.values.length>s.points)s.values=s.values.slice(s.values.length-s.points);else s.values=[...new Array(s.points-s.values.length).fill(0),...s.values]}}}else if(Array.isArray(s.values))s.values=[...new Array(points-s.values.length).fill(0),...s.values];else s.values=new Array(s.points).fill(0);let min=s.ymin;let max=s.ymax;if(min===max){max=s.values.length<=1e5?Math.max(...s.values):1;min=s.values.length<=1e5?Math.min(...s.values):0}else if(isNaN(max)){max=s.values.length<=1e5?Math.max(...s.values):1}if(isNaN(min)){min=s.values.length<=1e5?Math.min(...s.values):0}if(min>max){let t=min;max=min;min=t}let abs=Math.abs(min);s.absmax=abs>max?abs:max;if(!("autoscale"in s))s.autoscale=true;if(!s.position)s.position=settings.nLines-i-1;if(s.autoscale){if(s.autoscale===2){if(!("clamp"in s))s.clamp=true;s.scaled=WebglLinePlotUtil.autoscale(s.values,s.position,nLines,s.centerZero,min,max,s.clamp)}else{s.scaled=s.values;s.line.scaleY=WebglLinePlotUtil.getYScalar(s.values,nLines,s.centerZero,min,max);s.line.offsetY=WebglLinePlotUtil.getYOffset(s.position,nLines,min,s.line.scaleY)}}else s.scaled=s.values;s.scaled.forEach((y,i2)=>s.line.setY(i2,y));if(s.line instanceof WebglThickLine)plot.addThickLine(s.line);else if(s.line instanceof WebglLine)plot.addDataLine(s.line);if(!("xAxis"in s))s.xAxis=true;if(s.xAxis){if(s.xColor){if(Array.isArray(s.xColor))s.xColor=new ColorRGBA(...s.xColor)}else s.xColor=new ColorRGBA(1,1,1,.3);let x=new WebglLine(s.xColor,2);let xHeight=s.autoscale?(i+1)*2/nLines-1-1/nLines:0;x.constY(xHeight);x.arrangeX();x.xy[2]=1;s.x=x;plot.addAuxLine(x)}if(nLines>1&&s.autoscale&&i!==nLines-1){if(settings.dividerColor){if(Array.isArray(settings.dividerColor))settings.dividerColor=new ColorRGBA(...settings.dividerColor)}else settings.dividerColor=new ColorRGBA(1,1,1,1);let divider=new WebglLine(settings.dividerColor,2);divider.constY(s.autoscale?(i+1)*2/nLines-1:1);divider.arrangeX();divider.xy[2]=1;s.divider=divider;plot.addAuxLine(divider)}if(typeof settings.overlay==="object"){if(s.useOverlay||!("useOverlay"in s)){let pos=settings.nLines-s.position-1;ctx.fillText(line,20,canvas.height*(pos+.2)/settings.nLines);ctx.fillText(`${Math.floor(max)===max?max:max?.toFixed(5)} ${s.units?s.units:""}`,canvas.width-100,canvas.height*(pos+.2)/settings.nLines);ctx.fillText(`${Math.floor(min)===min?min:min?.toFixed(5)} ${s.units?s.units:""}`,canvas.width-100,canvas.height*(pos+.9)/settings.nLines)}}i++}requestAnimationFrame(info.anim);return this.plots[settings._id]}deinitPlot(info){if(typeof info==="string")info=this.plots[info];info.plot.clear();info.plot.removeAllLines();return true}reinitPlot(info,settings){if(typeof info==="string"){let str=info;info=this.plots[info];if(!settings._id)settings._id=str}if(!info.plot)return void 0;info.plot.clear();info.plot.removeAllLines();if(info.settings.overlayCtx)info.settings.overlayCtx.clearRect(0,0,info.settings.overlay?.width,info.settings.overlay?.height);return this.initPlot(settings,info.plot)}getChartSettings(plotId,getValues){let info=this.plots[plotId];if(info){let settings=Object.assign({},info.initial);for(const l in info.initial.lines){if(typeof info.initial.lines[l]?.ymax!=="number"){settings.lines[l].ymax=info.settings.lines[l]?.ymax}if(typeof info.initial.lines[l]?.ymin!=="number"){settings.lines[l].ymin=info.settings.lines[l]?.ymin}if(getValues)settings.lines[l].values=info.settings.lines[l].values}delete settings.canvas;delete settings.overlay;delete settings.overlayCtx;return settings}return void 0}update(plotInfo,lines,draw=true){if(typeof plotInfo==="string")plotInfo=this.plots[plotInfo];if(!plotInfo)return false;if(lines){let regenerate=false;let canvas;let ctx;if(typeof plotInfo.settings.overlay==="object"){canvas=plotInfo.settings.overlay;ctx=plotInfo.settings.overlayCtx;ctx.font=plotInfo.settings.overlayFont?plotInfo.settings.overlayFont:"1em Courier";ctx.fillStyle=plotInfo.settings.overlayColor?plotInfo.settings.overlayColor:"white"}for(const line in lines){if(plotInfo.settings.lines[line]&&plotInfo.settings.lines[line].line){if(plotInfo.settings.lines[line]?.viewing===false)continue;let s=plotInfo.settings.lines[line];if(Array.isArray(lines[line])){WebglLinePlotUtil.circularBuffer(s.values,lines[line])}else if(typeof lines[line]==="number"){s.values.push(lines[line]);s.values.shift()}else if(lines[line]?.values){WebglLinePlotUtil.circularBuffer(s.values,lines[line].values)}if(s.values){if(s.values.length!==s.points){if(s.interpolate){if(s.values.length>s.points){s.values=WebglLinePlotUtil.downsample(s.values,s.points)}else if(s.scaled.length<s.points){s.values=WebglLinePlotUtil.upsample(s.values,s.points)}}else{if(s.values.length>s.points)s.values.splice(0,s.values.length-s.points);else s.values=new Array(s.points).fill(0).splice(s.points-s.values.length,0,s.values)}}let min=s.ymin;let max=s.ymax;if(min===max){max=s.values.length<=1e5?Math.max(...s.values):1;min=s.values.length<=1e5?Math.min(...s.values):0}else if(isNaN(max)){max=s.values.length<=1e5?Math.max(...s.values):1}if(isNaN(min)){min=s.values.length<=1e5?Math.min(...s.values):0}if(min>max){let t=min;max=min;min=t}let abs=Math.abs(min);s.absmax=abs>max?abs:max;if(s.autoscale){if(s.autoscale===2)s.scaled=WebglLinePlotUtil.autoscale(s.values,s.position,plotInfo.settings.nLines,s.centerZero,min,max,s.clamp);else{s.scaled=s.values;s.line.scaleY=WebglLinePlotUtil.getYScalar(s.values,plotInfo.settings.nLines,s.centerZero,min,max);s.line.offsetY=WebglLinePlotUtil.getYOffset(s.position,plotInfo.settings.nLines,min,s.line.scaleY)}}else s.scaled=s.values;s.scaled.forEach((y,i)=>{if(!s.autoscale&&s.absmax>1){s.line.setY(i,y/s.absmax)}else s.line.setY(i,y)});if(typeof plotInfo.settings.overlay==="object"){if(s.useOverlay||!("useOverlay"in s)){let pos=plotInfo.settings.nLines-s.position-1;ctx.clearRect(0,canvas.height*pos/plotInfo.settings.nLines,canvas.width,canvas.height/plotInfo.settings.nLines);ctx.fillText(line,20,canvas.height*(pos+.2)/plotInfo.settings.nLines);ctx.fillText(`${Math.floor(max)===max?max:max?.toFixed(5)} ${s.units?s.units:""}`,canvas.width-100,canvas.height*(pos+.2)/plotInfo.settings.nLines);ctx.fillText(`${Math.floor(min)===min?min:min?.toFixed(5)} ${s.units?s.units:""}`,canvas.width-100,canvas.height*(pos+.9)/plotInfo.settings.nLines)}}}}else if(plotInfo.settings.generateNewLines&&!line.includes("timestamp")){if(Array.isArray(lines[line])){lines[line]={values:lines[line]}}if(!lines[line].nSec&&!lines[line].nPoints){lines[line].nPoints=1e3}regenerate=true}}if(regenerate){if(!plotInfo.settings.cleanGeneration){Object.keys(plotInfo.initial.lines).forEach(k=>{if(!lines[k])lines[k]=plotInfo.initial.lines[k];else{lines[k]=Object.assign(plotInfo.initial.lines[k],lines[k])}})}this.reinitPlot(plotInfo,{_id:plotInfo.settings._id,lines});return true}}if(draw)requestAnimationFrame(plotInfo.anim);return true}updateLine(line,values,interpolate,autoscale,autoscalePosition,nLines,centerZero){if(line.numPoints!==values.length){if(interpolate){if(line.numPoints>values.length){values=WebglLinePlotUtil.downsample(values,line.numPoints)}else if(line.numPoints<values.length){values=WebglLinePlotUtil.upsample(values,line.numPoints)}}else{if(values.length>line.numPoints)values=values.slice(values.length-line.numPoints);else values=[...new Array(values.length).fill(0),...values]}}if(autoscale){values=WebglLinePlotUtil.autoscale(values,autoscalePosition,nLines,centerZero)}values.forEach((y,i)=>line.setY(i,y));return true}static autoscale(array,lineIdx=0,nLines=1,centerZero=false,ymin,ymax,clamp){if(array?.length===0)return array;let max=typeof ymax==="number"?ymax:array.length<=1e5?Math.max(...array):1;let min=typeof ymin==="number"?ymin:array.length<=1e5?Math.min(...array):0;let _lines=1/nLines;let scalar=1;if(centerZero){let absmax=Math.max(Math.abs(min),Math.abs(max));if(absmax!==0)scalar=_lines/absmax;return array.map(y=>{if(clamp){if(y<min)y=min;if(y>max)y=max}return y*scalar+(_lines*(lineIdx+1)*2-1-_lines)})}else{if(max===min){if(max!==0){scalar=_lines/max}else if(min!==0){scalar=_lines/Math.abs(min)}}else scalar=_lines/(max-min);return array.map(y=>{if(clamp){if(y<min)y=min;if(y>max)y=max}return 2*((y-min)*scalar-1/(2*nLines))+(_lines*(lineIdx+1)*2-1-_lines)})}}static getYScalar(array,nLines=1,centerZero=false,ymin,ymax){if(array?.length===0)return array;let max=typeof ymax==="number"?ymax:array.length<=1e5?Math.max(...array):1;let min=typeof ymin==="number"?ymin:array.length<=1e5?Math.min(...array):0;let _lines=1/nLines;let scalar=1;if(centerZero){let absmax=Math.max(Math.abs(min),Math.abs(max));if(absmax!==0)scalar=_lines/absmax;return 2*scalar}else{if(max===min){if(max!==0){scalar=_lines/max}else if(min!==0){scalar=_lines/Math.abs(min)}}else scalar=_lines/(max-min);return 2*scalar}}static getYOffset(lineIdx=0,nLines=1,min=0,scalar=1){let _lines=1/nLines;let offset=_lines*(lineIdx+1)*2-1-_lines;if(min>0)offset-=min*scalar+1/nLines;return offset}static absmax(array){return Math.max(Math.abs(Math.min(...array)),Math.max(...array))}static downsample(array,fitCount,scalar=1){if(array.length>fitCount){let output=new Array(fitCount);let incr=array.length/fitCount;let lastIdx=array.length-1;let last=0;let counter=0;for(let i=incr;i<array.length;i+=incr){let rounded=Math.round(i);if(rounded>lastIdx)rounded=lastIdx;for(let j=last;j<rounded;j++){output[counter]+=array[j]}output[counter]/=(rounded-last)*scalar;counter++;last=rounded}return output}else return array}static upsample(array,fitCount,scalar=1){var linearInterpolate=function(before2,after2,atPoint2){return(before2+(after2-before2)*atPoint2)*scalar};var newData=new Array(fitCount);var springFactor=(array.length-1)/(fitCount-1);newData[0]=array[0];for(var i=1;i<fitCount-1;i++){var tmp=i*springFactor;var before=Math.floor(tmp);var after=Math.ceil(tmp);var atPoint=tmp-before;newData[i]=linearInterpolate(array[before],array[after],atPoint)}newData[fitCount-1]=array[array.length-1];return newData}static interpolate(array,fitCount,scalar=1){if(array.length>fitCount){return WebglLinePlotUtil.downsample(array,fitCount,scalar)}else if(array.length<fitCount){return WebglLinePlotUtil.upsample(array,fitCount,scalar)}return array}static HSLToRGB(h,s,l,scalar=255){s/=100;l/=100;let c=(1-Math.abs(2*l-1))*s,x=c*(1-Math.abs(h/60%2-1)),m=l-c/2,r=0,g=0,b=0;if(0<=h&&h<60){r=c;g=x;b=0}else if(60<=h&&h<120){r=x;g=c;b=0}else if(120<=h&&h<180){r=0;g=c;b=x}else if(180<=h&&h<240){r=0;g=x;b=c}else if(240<=h&&h<300){r=x;g=0;b=c}else if(300<=h&&h<360){r=c;g=0;b=x}r=(r+m)*scalar;g=(g+m)*scalar;b=(b+m)*scalar;return[r,g,b]}static circularBuffer(arr,newEntries){if(newEntries.length<arr.length){let slice=arr.slice(newEntries.length);let len=arr.length;arr.splice(0,len,...slice,...newEntries)}else if(newEntries.length>arr.length){let len=arr.length;arr.splice(0,len,newEntries.slice(len-newEntries.length))}else{arr.splice(0,arr.length,...newEntries)}return arr}static formatDataForCharts(data,key){if(Array.isArray(data)){if(Array.isArray(data[0])){let d={};data.forEach((arr,i)=>{d[i]=arr});data=d;if(isNaN(data[0][0]))return void 0}else if(key){data={[key]:data};if(isNaN(data[key][0]))return void 0}else{data={0:data};if(isNaN(data[0][0]))return void 0}}else if(typeof data==="object"){for(const key2 in data){if(typeof data[key2]==="number")data[key2]=[data[key2]];else if(data[key2]?.values){if(typeof data[key2].values==="number")data[key2].values=[data[key2].values]}if(isNaN(data[key2][0]))return void 0}}else if(typeof data==="string"){let split;if(data.includes("\r\n")){let lines=data.split("\r\n");data={};lines.forEach((l,j)=>{if(l.includes("	")){split=l.split("	")}else if(l.includes(",")){split=l.split(",")}else if(l.includes("|")){split=l.split("|")}if(split)split.forEach((val,i)=>{if(val.includes(":")){let[key2,v]=val.split(":");let fl=parseFloat(v);if(!isNaN(fl))data[key2]=[fl]}else{let fl=parseFloat(val);if(!isNaN(fl))data[i]=[fl]}})})}else if(data.includes("	")){split=data.split("	")}else if(data.includes(",")){split=data.split(",")}else if(data.includes("|")){split=data.split("|")}data={};if(split){split.forEach((val,i)=>{if(val.includes(":")){let[key2,v]=val.split(":");let fl=parseFloat(v);if(!isNaN(fl))data[key2]=[fl]}else{let fl=parseFloat(val);if(!isNaN(fl))data[i]=[fl]}})}}else if(typeof data==="number"){if(key)data={[key]:[data]};else data={0:[data]}}return data}static padTime(data,lastValue,time,targetFit){let slopeIncr=(data[0]-lastValue)/time/targetFit;let padded=[...new Array(targetFit-data.length).map((_,i)=>lastValue+slopeIncr*(i+1)),...data];return padded}static interpolateForTime(data,time,targetSPS){return WebglLinePlotUtil.interpolate(data,Math.ceil(targetSPS*time))}};globalThis.plotter=new WebglLinePlotUtil;var routes={...workerCanvasRoutes};self.onmessage=ev=>{if(ev.data.route){if(Array.isArray(ev.data.args)){routes[ev.data.route](...ev.data.args)}else routes[ev.data.route](ev.data.args)}};var canvas_worker_default=self;})();
